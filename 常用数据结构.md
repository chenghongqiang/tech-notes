# 常用数据结构 #

本文包括数据结构的预备知识、表、栈、队列、树、散列、堆等常见数据结构的介绍

## 预备知识 ##

### 递归简论 ###

在编写递归函数时，要遵循如下准则：

- 必须要有**基准情形**，无需递归就可以解出。
- 每一次递归调用都必须要朝向一种基准情形推进，不能南辕北辙，导致递归永远无法结束。
- 假设所有的递归调用都能运行，也就是说不必试图追踪大量递归调用的细节，因为这往往很复杂。
- 切勿在不同的递归调用中做重复性的工作。

### 算法分析 ###

**分治策略**是一种常用的算法分析思想，“分”的阶段将问题拆分成两个大致相等的子问题，然后递归地进行求解；“治”的阶段将两个子问题的解合并起来，再做少量附加工作，从而得到整个问题的解。很多情况下，分治算法可以将原本耗费O(N)时间的算法减少到O(logN)时间。例如如下几个算法：

- **二分查找**：算法过程略。注意：该算法要求输入序列是排好序的。代码如下：
		
		public static <AnyType extends Comparable<? super AnyType>> int binarySearch( AnyType [] a, AnyType x ){
			//初始化工作
	        int low = 0, high = a.length - 1;		
			//进行二分查找的迭代过程
	        while( low <= high ){
				//取中点元素
	            int mid = ( low + high ) / 2;
				//如果中点元素小于待查找元素，说明待查找元素在后半部分，迭代这个过程
	            if( a[ mid ].compareTo( x ) < 0 )
	                low = mid + 1;
				//如果中点元素大于待查找元素，说明待查找元素在前半部分，迭代这个过程
	            else if( a[ mid ].compareTo( x ) > 0 )
	                high = mid - 1;
	            //中点元素就是待查找元素，方法返回
				else
	                return mid;
	        }
			//若迭代循环结束，方法仍未返回，说明没有找到
	        return NOT_FOUND;
	    }

- **幂运算**：计算X的N次方，传统的算法是使用N-1次自乘，因此其花费时间是O(N)；而一种采用分治策略的递归算法效果更好——若N=0或1，直接算出结果，否则，若N是偶数，则`X^N = X^(N/2) * X^(N/2)`,只需递归求解`X^(N/2)`即可，若N是奇数，则`X^N = X^(N-1)/2 * X^(N-1)/2 * X`，只需递归求解`X^(N-1)/2`即可。可以看出，这种求幂运算的算法每次可以将问题的大小减半，因此该算法具有O(logN)时间。代码如下：

		public static long pow( long x, int n ){
			//计算x的0次方，直接计算
	        if( n == 0 )
	            return 1;
			//计算x的1次方，直接计算
	        if( n == 1 )
	            return x;
			//若n为偶数（n>1），则递归计算x^2的n/2次方即可
	        if( isEven( n ) )
	            return pow( x * x, n / 2 );
			//若n为奇数（n>1），则递归计算x^2的n/2次方，再乘以x即可
	        else
	            return pow( x * x, n / 2 ) * x;
	    }


## 表 ##

### 基本概念及理论 ###

- 表有两种常用的实现方式：**顺序表**和**链表**，分别对应于Java容器API中的ArrayList和LinkedList。
- 对于顺序表ArrayList，其底层是数组实现的，因此ArrayList本质上相当于一个可增长数组。可增长机制的实现原理是：在创建ArrayList时先根据默认长度建立一个数组，在向ArrayList中添加元素时，若初始的数组长度已不够用，则创建一个新的数组（一般为原数组的两倍长），把原数组的元素都拷贝到新数组中，后续使用的就是这个长度扩大的新数组了。ArrayList可增长机制的实现代码如下所示：

		public void ensureCapacity( int newCapacity ){
			//容量未满，无需增大容量，直接返回
	        if( newCapacity < theSize )
	            return;
			//获得原数组
	        AnyType [] old = theItems;
			//建立容量扩大后的新数组
	        theItems = (AnyType []) new Object[ newCapacity ];
	        //将原数组中的内容拷贝至新数组中
			for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
		}

- 对于链表LinkedList，其底层实现需要一个嵌套的节点类Node，该嵌套类中包含数据域、前一节点和后一节点的引用（Node对象引用）。
- 对于随机访问操作，ArrayList的处理效率较高，因为它底层是数组实现的；而LinkedList的处理效率较低，因为它需要从链表的表头（或表尾）逐个元素进行访问，直到到达要访问的元素为止。ArrayList和LinkedList中的随机访问操作方法的实现代码如下所示：
	
		//ArrayList中的随机访问方法
		public AnyType get( int idx ){
			//若随机访问的下标越界，抛出异常
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
			//根据随机访问的下标直接返回数组元素
	        return theItems[ idx ];    
	    }

		//LinkedList中的随机访问方法
		private Node<AnyType> getNode( int idx, int lower, int upper ){
	        Node<AnyType> p;
	        //若随机访问的下标越界，抛出异常
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        //若随机访问的下标在前半部分，则从头节点开始，向后逐个访问，直到找到元素
	        if( idx < size( ) / 2 )
	        {
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
			//若随机访问的下标在后半部分，则从尾节点开始，向前逐个访问，直到找到元素
	        else
	        {
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        } 
	        //返回找到的元素
	        return p;
	    }
- 对于添加和删除操作，ArrayList的处理效率较低，因为在向数组的某个位置添加/删除元素时，需要将该位置之后的所有元素后移/前移一位；而LinkedList的处理效率较高，因为它只需适当调整该位置前、后节点的引用即可。ArrayList和LinkedList中的添加、删除操作方法的实现代码如下所示：

		//ArrayList中的添加方法
		public void add( int idx, AnyType x ){
			//若空间不够，扩大容量
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );
			//为了空出插入的位置，要将插入位置之后的所有元素后移一位
	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];
			//插入新元素
	        theItems[ idx ] = x;
			//List的长度加1
	        theSize++;  
	    }

		//ArrayList中的删除方法
		public AnyType remove( int idx ){
			//获取被删除的元素
	        AnyType removedItem = theItems[ idx ];
	        //将删除位置之后的所有元素前移一位
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
			//List的长度减1
	        theSize--;    
	        //返回被删除的元素
	        return removedItem;
	    }

		//LinkedList中的添加方法
		private void addBefore( Node<AnyType> p, AnyType x ){
			//创建要插入的新节点
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
			//接下来两行代码是调整新节点及其插入位置的前节点的相关引用，从而完成链表的插入
	        newNode.prev.next = newNode;
	        p.prev = newNode; 
			//List长度加1        
	        theSize++;
	    } 

		//LinkedList中的删除方法
		private AnyType remove( Node<AnyType> p ){
			//调整待删除节点的前、后节点的相关引用，使其绕过待删除节点，即可完成删除
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        //List长度减1
			theSize--;
	        //返回待删除元素
	        return p.data;
	    }
		
- ArrayList和LinkedList中都实现了迭代器Iterator，迭代器是一个内部类（之所以使用内部类，而不使用外部类或嵌套类，是因为内部类对象中包含了对外部类对象的隐式引用，因此不需要写额外的代码，迭代器就可以获取外部类List的引用，从而访问List中的元素）。

- 关于迭代器的使用，有两点需要注意：
 
	+ 尽量使用迭代器的remove()方法，而不要使用List自身的remove()方法，因为List自身的remove()方法需要先找到该元素，然后删除；而迭代器的remove()方法直接删除游标指向的当前项。
	+ 只有在需要立即使用一个迭代器的时候，才应该获取迭代器。因为如果对正在被迭代的容器进行结构上的改变（例如添加、删除等操作），则先前获取的迭代器将不再合法。


## 栈 ##

### 基本概念及理论 ###

- 栈是一种先进后出（FILO）的数据结构，它本质上是限制添加和删除操作只能在一个位置上（栈顶）进行的表，因此任何实现表的方法（例如ArrayList和LinkedList）都可以实现栈。
- 栈操作包括**入栈**（push）和**出栈**（pop），这些操作都是在栈顶进行的，且都花费常数时间。

### 栈的应用 ###

- 编译器检查代码中的括号是否正确配对。
- 将中缀表达式转换成后缀表达式，并计算后缀表达式。（示例略）
- 方法调用（包括递归调用）。（注意：对于尾调用和尾递归，由于调用完成之后直接返回，没有后续操作了，因此无需在方法调用栈上添加新的栈帧，而仅仅更新原来的栈帧即可。所以编译器一般都会进行尾调用消除，来优化程序执行效率。）


## 队列 ##

### 基本概念及理论 ###

- 队列是一种先进先出（FIFO）的数据结构，它本质上也是表，因此任何实现表的方法（例如ArrayList和LinkedList）都可以实现队列。
- 队列的操作包括**插入**（enqueue）和**删除**（dequeue）。插入在队尾进行，删除在队头进行，均花费常数时间。
- 队列的数组实现会存在**假溢出**的问题，解决方法是将队列变成循环队列，当到达数组末端时重新绕回到开头。

### 队列的应用 ###

- 排队论
- 消息队列JMS


## 树 ##

### 基本概念及理论 ###

- 树的实现一般采用firstChild-nextSibling方法，即每个节点保存指向它的第一个儿子和它的右兄弟的链（由于事先不知道每个节点的儿子数目，因此直接保存指向所有儿子的链这种做法是不可行的，会产生太多浪费的空间）。
- 对于二叉树，由于每个节点最多有两个子节点，因此不必采用firstChild-nextSibling的实现方法，而可以直接保存指向子节点的链。

### 二叉查找树 ###

- 二叉查找树是非常重要的一种树，它的性质是:对于每一个节点，其左子树中所有项的值 < 该节点项的值 < 其右子树中所有项的值。因此二叉查找树是有序的。
- **contains方法**：在二叉查找树中查找某个元素是否存在，算法过程为：首先访问树的根节点，若待查找的值等于根节点的值，则找到返回；否则，若待查找的值小于/大于根节点的值，则对根节点的左子树/右子树进行递归的查找。该算法代码如下：

		private boolean contains( AnyType x, BinaryNode<AnyType> t ){
			//若当前节点为空，说明未找到，返回false
	        if( t == null )
	            return false;
	        //比较待查找的值与当前节点值
	        int compareResult = x.compareTo( t.element );
	        //若待查找的值小于当前节点值，则对当前节点的左子树进行递归查找
	        if( compareResult < 0 )
	            return contains( x, t.left );
			//若待查找的值大于当前节点值，则对当前节点的右子树进行递归查找
	        else if( compareResult > 0 )
	            return contains( x, t.right );
	        //若待查找的值等于当前节点值，则说明找到了
			else
	            return true;
	    }

- **findMin/findMax操作**：找到二叉查找树中的最小/最大元素，findMin算法过程为：从树的根节点开始，只要左儿子存在，就访问左儿子，直到终止。这个过程用递归和迭代都可以实现。findMax的算法过程与之类似。代码如下：

		//用递归的方法实现findMin
		private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t ){
			//若当前节点为null，说明是空树，返回null
	        if( t == null )
	            return null;
			//若当前节点没有左儿子，说明当前节点就是最小元素，返回之
	        else if( t.left == null )
	            return t;
			//若当前节点有左儿子，则递归地在左子树中查找
	        return findMin( t.left );
	    }

		//用迭代的方法实现findMax
		private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t ){
			//若当前节点不为空，则迭代地访问当前节点的右儿子，直到没有右儿子为止，此时该节点就是最大元素
	        if( t != null )
	            while( t.right != null )
	                t = t.right;
	        return t;
	    }

- **insert操作**：向二叉查找树中插入新元素。为了将元素插入到合适的位置，可以先使用contain方法进行查找，若找到，说明树中已经存在待插入的元素了，什么都不做即可；若没有找到，则将新元素插入到查找路径的终止点上（该终止点就是新元素应该在的位置）。代码如下：

		private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t ){
			//若当前节点为空，则直接创建新节点并返回
	        if( t == null )
	            return new BinaryNode<>( x, null, null );
	        //比较待插入元素值与当前节点的值
	        int compareResult = x.compareTo( t.element );
	        /*若待插入元素值小于当前节点的值，说明应该插入到当前节点的左子树上，因此在左子
			树上递归地调用insert方法，方法返回值为插入完成之后的左子树，用其更新原来的左子
			树*/
	        if( compareResult < 0 )
	            t.left = insert( x, t.left );
			/*若待插入元素值大于当前节点的值，说明应该插入到当前节点的右子树上，因此在右子
			树上递归地调用insert方法，方法返回值为插入完成之后的右子树，用其更新原来的右子
			树*/
	        else if( compareResult > 0 )
	            t.right = insert( x, t.right );
			//若待插入元素等于当前节点的值，说明待插入元素在树中已存在，则什么都不做
	        else
	            ;
			//最终返回完成插入操作之后的当前节点
	        return t;
	    }

- **remove操作**：从二叉查找树中删除指定的元素。需要分三种情况考虑：
	+ 待删除的节点没有儿子（也即它是一片树叶）：直接删除该节点即可。
	+ 待删除的节点有一个儿子：该节点可以在其父节点调整自己的链以绕过该节点后被删除。
	+ 待删除的节点有两个儿子：可以巧妙地化为第一种或第二种情况：用该节点的右子树中最小的元素（很容易找到）代替该节点，然后递归地删除右子树中最小的元素。由于右子树中最小的元素不可能有左儿子，因此它最多有一个儿子，所以问题转化为了前两种情况。
	+ remove方法的代码如下：
	
			private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t ){
				//若当前节点为空，则不需要删除，直接返回当前节点
		        if( t == null )
		            return t;
		        //比较待删除的元素值和当前节点值
		        int compareResult = x.compareTo( t.element );
		        /*若待删除的元素值小于当前节点值，说明待删除的元素在当前节点的左子树中，
				所以对左子树递归地调用remove方法*/
		        if( compareResult < 0 )
		            t.left = remove( x, t.left );
				/*若待删除的元素值大于当前节点值，说明待删除的元素在当前节点的右子树中，
				所以对右子树递归地调用remove方法*/
		        else if( compareResult > 0 )
		            t.right = remove( x, t.right );
				/*若待删除元素值等于当前节点值，说明当前节点就是待删除的元素，并且若当前
				节点有两个儿子，则符合上述第三种情况，首先用该节点的右子树中最小的元素代替
				该节点，然后递归地删除右子树中最小的元素*/
		        else if( t.left != null && t.right != null )
		        {
		            t.element = findMin( t.right ).element;
		            t.right = remove( t.element, t.right );
		        }
				/*若当前节点就是待删除的元素，并且当前节点只有零个或一个儿子，则符合上述
				前两种情况，进行相应操作即可*/
		        else
		            t = ( t.left != null ) ? t.left : t.right;
				//最终返回完成删除操作之后的当前节点
		        return t;
		    }

	+ 注意：上述的删除策略总是倾向于使左子树比右子树更深（因为第三种情况下，是使用右子树的最小元素来代替待删除节点，并最终递归删除右子树的最小元素，这会导致右子树的元素越来越少）。消除这种不平衡可以采用这种做法：每次删除时随机选取右子树的最小元素或左子树的最大元素来代替待删除节点，这样有时左子树的元素减少，有时右子树的元素减少，可以保证一定的平衡性。
	+ 除了上述的删除策略外，还可以采用**懒惰删除**，即被删除的节点仍旧留在树中，只是被标记为删除。

- **merge操作**：合并两个二叉查找树。可以先对两棵树分别执行中序遍历（后面有详述），得到两个有序的数组，然后采用归并排序将两个数组合并为一个大的有序数组，最后再将这个大的有序数组重新建立成二叉查找树即可。（注意：最后一步中，由于输入数组是有序的，因此如果采用连续insert操作建立二叉查找树的话，该树会退化成链表，导致后续操作效率很低，故需要将其调整为带有平衡条件的树，如AVL树。关于带有平衡条件的树，后面有详述）。

### AVL树 ###

- 普通的二叉查找树有可能会出现严重的不平衡，例如向一棵空树输入预先排好序的数据，则该树最终将退化成一个链表（所有的节点都只有右儿子，没有左儿子），从而导致该树深度太大，查找、插入等操作的效率很低。
- 为了解决普通二叉查找树的不平衡现象，有很多不同的实现方案，包括最古老的AVL树、伸展树、红黑树等等。
- AVL树是带有平衡条件的二叉查找树，它必须时刻保持树的平衡，也即保证树的深度是O(logN)。它需要满足的平衡条件是：其每个节点的左子树和右子树的高度最多相差1。
- 当向一棵AVL树插入元素时，有可能会破坏平衡条件，因此需要对插入之后的树进行修正，称之为**旋转**，旋转包括**单旋转**和**双旋转**，其中单旋转又包括**左旋转**和**右旋转**，双旋转包括先左旋转再右旋转，或先右旋转再左旋转。旋转的同时还应保持二叉查找树的特性（左儿子 < 节点 < 右儿子）。对于旋转操作的形象化理解，可以这样想象：把树看成是柔软灵活的，抓住作为旋转轴的节点，将其拎起来，在重力的作用下，该节点就成为了新的根节点。单旋转和双旋转的代码示例如下：

		//单旋转（左旋转）
		private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 ){
			//调整旋转涉及到的节点的链，从而完成旋转
	        AvlNode<AnyType> k1 = k2.left;
	        k2.left = k1.right;
	        k1.right = k2;
	        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
	        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
			//返回旋转完成之后的根节点（原来根节点的左儿子现在成为了新的根节点）
	        return k1;
	    }
		
		//单旋转（右旋转）
		private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 ){
			//调整旋转涉及到的节点的链，从而完成旋转
	        AvlNode<AnyType> k2 = k1.right;
	        k1.right = k2.left;
	        k2.left = k1;
	        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
	        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
			//返回旋转完成之后的根节点（原来根节点的右儿子现在成为了新的根节点）
	        return k2;
	    }

		//双旋转（先右旋转，再左旋转）
		private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 ){
			//先右旋转
	        k3.left = rotateWithRightChild( k3.left );
			//再左旋转
	        return rotateWithLeftChild( k3 );
	    }

		//双旋转（先左旋转，再右旋转）
		private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 ){
			//先左旋转
	        k1.right = rotateWithLeftChild( k1.right );
			//再右旋转
	        return rotateWithRightChild( k1 );
	    }

	向AVL树插入元素的示例代码如下：
		
		private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t ){
			//以下代码与普通二叉查找树的插入实现代码一样
	        if( t == null )
	            return new AvlNode<>( x, null, null );
	        int compareResult = x.compareTo( t.element );        
	        if( compareResult < 0 )
	            t.left = insert( x, t.left );
	        else if( compareResult > 0 )
	            t.right = insert( x, t.right );
	        else
	            ;

			//插入完成之后，要通过旋转操作进行修正，使AVL树重新满足平衡条件（balance方法代码略）
	        return balance( t );
	    }

	从AVL树中删除元素的示例代码如下：

		private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t ){
			//以下代码与普通二叉查找树的删除实现代码一样
	        if( t == null )
	            return t;     
	        int compareResult = x.compareTo( t.element );    
	        if( compareResult < 0 )
	            t.left = remove( x, t.left );
	        else if( compareResult > 0 )
	            t.right = remove( x, t.right );
	        else if( t.left != null && t.right != null )
	        {
	            t.element = findMin( t.right ).element;
	            t.right = remove( t.element, t.right );
	        }
	        else
	            t = ( t.left != null ) ? t.left : t.right;

			//删除完成之后，要通过旋转操作进行修正，使AVL树重新满足平衡条件（balance方法代码略）
	        return balance( t );
	    }

### 伸展树 ###

伸展树的思路是：允许单次操作花费O(N)时间，但是每次访问一个节点之后，会将该节点上推到树根（通过一系列的旋转操作），使得该节点及其路径上的其他节点在下次访问时可以快很多。因此伸展树不保证每次操作都花费O(logN)时间，但是可以保证连续M次操作的总时间为O(M * logN)。也就是说，伸展树每次操作的**摊还代价**仍是O(logN)。伸展树的具体分析比较复杂，此处省略。

### 红黑树 ###

- 红黑树与AVL树类似，也是带有某些平衡条件的二叉查找树。它的每个节点上都有存储位表示节点颜色，可以是红色或黑色。
- 红黑树应满足的特性此处省略，但应记住：它的特性确保了树中没有一条路径会比其他路径长出一倍以上，因此红黑树是接近于平衡的。
- 在对红黑树进行插入和删除操作后，与AVL树类似，也需要进行旋转和重新着色等操作来修正该树。旋转包括左旋转和右旋转，与AVL树的左旋转和右旋转操作方式一样。
- 红黑树与AVL树的比较
	+ AVL树相对简单，红黑树比较复杂，尤其是红黑树的插入和删除操作，要考虑很多情况。
	+ AVL树是高度平衡的树（任一节点的左右子树高度差不能超过1），每一次对树的插入和删除操作都需要进行修正；红黑树的平衡程度要比AVL树略低（任意两个节点到根节点的路径相差不超过一倍），每次插入最多只需要两次旋转，删除最多只需要三次旋转。
	+ 由于AVL树是高度平衡的，因此其查找效率比较稳定；红黑树要略差一些。

- 红黑树的应用：
	+ 关联数组的实现
	+ Java中的TreeSet和TreeMap：这两种容器的底层实现都是红黑树，因此容器中的元素是有序的，并且组织树是接近平衡的，所以对TreeSet和TreeMap执行查找、插入和删除操作都只花费O(logN)时间。
	+ C++ STL中的set和map
	+ Linux中的虚拟内存管理

### 树的遍历 ###

树的遍历包括先序遍历（中左右）、中序遍历（左中右）、后序遍历（左右中），以及不常用的层序遍历。先序/中序/后序遍历的示例代码如下所示：

	//树的遍历的经典递归写法
	private void printTree( BinaryNode<AnyType> t ){
		//若当前节点不为空，则开始遍历
		if( t != null ){
			//接下来三行代码可以任意调整顺序，从而实现先序/中序/后序遍历。此处为中序遍历（左中右）
			printTree( t.left );
			System.out.println( t.element );
			printTree( t.right );
		}
	}

对于二叉查找树，执行一次中序遍历得到的是排好序的元素，这是排序算法的一种。
	
### B树 ###

- 上述讨论的所有种类的树都是放在主存中的。但是如果数据太多导致主存放不下，就需要将数据放在磁盘上。这时，影响树的操作效率的关键就不再是算法的时间复杂度了，而是对磁盘的I/O访问次数。相比一条算法指令的执行速度，对于磁盘的一次访问速度要慢的多，因此应该尽可能减少磁盘的访问次数。解决方法很简单：允许树有较多的分支，从而树的高度会降低，所以访问树中节点的磁盘I/O次数也会减少。
- B树就是这样的一种多叉树，它的具体特性此处省略。不过要注意：对于一棵B树，为了不让其退化成二叉树甚至是链表，应保证其任意节点（除根节点外）的儿子数至少要达到最大容量的一半，并且叶子节点存储的数据项个数也至少要达到最大容量的一半。
- 在对B树执行插入操作时，若数据项插入到的叶子节点已经满员，则需要将该叶子节点**分裂**成两个叶子节点；若此时该叶子节点的父节点也已满员，则继续分裂该父节点；以此类推，直至分裂到根节点。
- 在对B树执行删除操作时，若删除数据项之后，该叶子节点存储的数据项个数达不到最大容量的一半，则需要从相邻叶子节点**领养**元素。
- 插入时的分裂操作和删除时的领养操作都需要重新调整B树的结构，也即需要额外的磁盘I/O访问。但是经过一次分裂/领养之后，接下来的若干次插入/删除都无需再进行分裂/领养了，因此这点额外的代价是值得的。


## 散列 ##

### 基本概念与理论 ###

- **散列表**是一种将元素值经过**散列函数**计算后映射到相应的数组单元（散列表的底层实现是具有固定长度的数组）的数据结构。它执行插入、删除和查找操作都花费常数平均时间（执行这些操作只需要计算散列函数，然后直接访问对应的数组单元即可。但是如果散列表填的太满，会导致额外的操作开销，则时间界将不再有效）。
- 散列表的关键在于以下三点：
	+ **散列函数**：散列函数将元素值映射到0到TableSize-1这个范围中的某个整数，也即映射到散列表中的某个单元。理想的散列函数可以将元素均匀地分配到散列表的各个单元，而不会产生“扎堆”的现象。
	+ **冲突的解决**：当一个元素被插入时与另一个已经插入的元素散列到了相同的单元，那么就产生了冲突，这个冲突需要解决。主要有两种解决冲突的方式：**分离链接法**和**开放定址法**。
	+ **散列表的大小**：如何确定散列表的大小是很重要的，若处理不当容易产生扎堆的现象（例如散列函数为`元素值 mod 散列表的大小`，若散列表的大小为10，而元素值都是10的整数倍，那么所有的元素都会扎堆映射到第一个单元）。所以一般设置散列表的大小为**素数**。
	+ 一个散列函数的示例代码如下所示：
		
			public static int hash( String key, int tableSize ){
				//以下代码将元素值key经过一系列处理计算得到散列值hashVal，并最终返回
		        int hashVal = 0;	
		        for( int i = 0; i < key.length( ); i++ )
		            hashVal = 37 * hashVal + key.charAt( i );
		        hashVal %= tableSize;
		        if( hashVal < 0 )
		            hashVal += tableSize;
		        return hashVal;
		    }

### 冲突解决 ###

##### 分离链接法 #####

- 分离链接法对于冲突的解决方式是将散列到同一个单元的所有元素保存到一个双向链表LinkedList中，因此散列表的底层实现是一个链表数组。
- 对于查找操作，首先计算散列函数，确定待查找的元素处于哪个链表中；然后在该链表中再执行一次查找。示例代码如下：

		public boolean contains( AnyType x ){
			//先计算散列函数hash，确定待查找元素处在哪个链表中
	        List<AnyType> whichList = theLists[ hash( x ) ];
			//在这个链表中查找该元素，调用的是链表的contains方法
	        return whichList.contains( x );
	    }

- 对于插入和删除操作，也是先计算散列函数，确定具体对应于哪个链表；然后在该链表中进行插入和删除操作。示例代码如下：

		//插入操作
		public void insert( AnyType x ){
			//先计算散列函数，确定具体在哪个链表
	        List<AnyType> whichList = theLists[ hash( x ) ];
			//若待插入的元素在该链表中不存在，则插入该链表中（调用链表的add方法）
	        if( !whichList.contains( x ) )
	        {
	            whichList.add( x );
	            // 若散列表的大小不够用，要进行“再散列”操作，即扩充散列表的大小，后面有详述
	            if( ++currentSize > theLists.length )
	                rehash( );
	        }
	    }
	
		//删除操作
		public void remove( AnyType x ){
			//先计算散列函数，确定具体在哪个链表
	        List<AnyType> whichList = theLists[ hash( x ) ];
			//若该链表中包含待删除的元素，则删除之（调用链表的remove方法）
	        if( whichList.contains( x ) ){
	        	whichList.remove( x );
	            currentSize--;
	    	}
	    }

- 散列表的**装填因子λ**指的是散列表中的元素个数与散列表长度之比。因此对于分离链接法的散列表，链表的平均长度就是λ。λ越长，则一次查找平均要遍历的链表节点就越多，效率就越低。因此散列表的大小并不重要，而装填因子λ才是最重要的。一般来说，对于分离链接法的散列表，取λ=1（也即平均每个链表包含一个元素）效果较好。

##### 开放定址法 #####

- 开放定址法对于冲突的解决方式是尝试重新分配另外一些单元，直到找出空的单元为止。分离链接法允许一个单元存放多个元素（以链表的形式组织），而开放定址法只允许一个单元存放一个元素。因此对于采用开放定址法的散列来说，一般其装填因子λ要小于0.5，才能保证有足够的空闲单元供重新分配。所以若存放相同数量的元素，开放定址法所需的散列表大小比分离链接法所需的要大一些。
- 开放定址法探测并分配新单元的策略具体有以下三种：
	+ **线性探测法**：第i次探测的是从原单元开始往后第k * i个单元。例如相继探测原单元往后的第3、6、9、12、...个单元，直到找到空闲单元为止。这种探测方式会存在**一次聚集**的问题，也就是说对于新地址的探测也会产生扎堆现象（探测到相同的新单元），导致之后插入的元素需要经过很多次探测才能找到空闲单元。
	+ **平方探测法**：第i次探测的是从原单元开始往后第k * i^2个单元。例如相继探测原单元往后的第1、4、9、16、...个单元，直到找到空闲单元位置。这种探测方式可以解决一次聚集问题，但会导致**二次聚集**的问题。对于平方探测法，可以证明：若表的大小为素数，那么当表的装填因子λ < 0.5时，一定能够插入一个新的元素。这也说明了若表中的空闲单元不到一半（λ > 0.5），则插入有可能失败。
	+ **双散列**：第i次探测的是从原单元开始往后第f(i)个单元，其中f(i)是另一个散列函数。这个散列函数必须要选择得好——一定不能计算出0值，否则会一直停留在原单元；并且要能保证所有的空闲单元都能被探测到。


### 再散列 ###

无论是分离链接法和开放定址法，当散列表填的太满时，操作的运行时间都会开始变长（对于分离链接法，链表太长会导致查找效率降低；对于开放定址法，执行插入操作要经过更多次探测才能找到空闲单元，甚至有可能插入失败）。所以此时需要对散列表进行扩容，一般是建立一个大约两倍大的新表，并使用一个相关的新散列函数，将原表中的元素散列到新表中。这一操作称为**再散列**（rehash）。再散列一般有以下三种策略：

+ 只要表填满一半就进行再散列。
+ 当插入失败时再执行再散列。
+ 当散列表达到某一个装填因子λ时进行再散列。

### 可扩散列 ###

当数据量太大以至于主存中无法存放时，需要考虑的是如何减少磁盘I/O访问的次数（如同B树一样），此时可以采用**可扩散列**，它由**目录**和**数据**两部分组成，其中数据是以树叶的形式组织的。每个目录项指向一片树叶（树叶由具有相同前缀的数据构成，例如目录项“00”指向一片树叶，该树叶包含“00110”、“00100”等以“00”为前缀的数据）。当向可扩散列插入数据时，若要插入的树叶已满，则需要对树叶执行**分裂**（类似于B树执行插入操作时的分裂）。最后需要注意：可扩散列仅使用两次磁盘访问执行一次查找，并且插入操作也仅需要很少的磁盘访问。

### 散列的应用 ###

- 如果在组织数据时，不需要有序的信息，或者不确定输入数据是否已被排序，则应该优先选择散列这种数据结构，因为它执行查找、插入和删除操作平均只花费常数时间（在散列函数设计良好的情况下）。而若需要有序地组织数据，则应该优先选用二叉查找树，它的平均时间界是O(logN)。
- Java中的HashSet和HashMap底层是由散列（分离链接法）实现的，这两种容器类型执行查找、插入和删除平均只花费常数时间，一般来说比TreeSet和TreeMap的对数时间界在性能上要更优一些。此外，HashSet中存储的项和HashMap中存储的关键字必须实现equals和hashCode方法，从而可以完成散列值的计算和比较。
- 散列表的应用场景举例：
	+ 编译器使用散列表来跟踪源代码中声明的变量，因为这些变量不需要有序排列。
	+ 某些图论问题。
	+ 实时拼写检验程序：可以预先将整个词典散列，则实时输入的单词可以以常数时间被检测。


## 优先队列（堆） ##

### 基本概念及理论 ###

- 普通的队列只能按元素的存放顺序依次返回队头的元素，而返回最小（或最大）元素的操作代价较高。**优先队列（堆）**则支持高效地找到并返回最小（最大）的元素。
- 堆支持的操作主要包括**插入**和**删除最小元素**。

### 二叉堆 ###

- **二叉堆**是最常见的堆的实现，它是一棵**完全二叉树**，并且满足**堆序性质**：每个节点的值 <= 其子节点的值。
- 由于二叉堆是完全二叉树，而完全二叉树非常有规律（层序遍历一棵完全二叉树，则访问到的第i个元素的左儿子为第2i个元素、右儿子为第2i + 1个元素、父节点为第i/2个元素），所以二叉堆可以由最简单的数组来实现，无需使用链。数组中第i个元素的左儿子、右儿子、父节点分别是第2i、2i + 1、i/2个元素。
- **插入insert**：当插入一个元素时，首先在堆的下一个可用位置（即最底层从左往右数第一个空位置）创建一个空穴hole，如果新元素可以放在该空穴位置而并不破坏堆序性质，则插入完成；否则交换该空穴与其父节点，这一步称之为**上滤**（空穴向上移动一层，其父节点相应地向下填补位置），这样空穴就朝着根的方向前进了一层，继续该上滤过程，直到新元素可以被放入空穴而不破坏堆序性质为止。平均而言，一次插入操作需要执行1.607次上滤，也即平均花费常数时间O(1)；最坏情况下，空穴要上滤到根节点，因此最坏运行时间为O(logN)。示例代码如下：

		//二叉堆的插入操作
		public void insert( AnyType x ){
			//若堆已满，则扩大一倍容量
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );	
	        //创建空穴hole
	        int hole = ++currentSize;
			/*若新元素小于空穴的父节点元素，则说明将新元素放在空穴会破坏堆序性质，需要执行
			上滤，并迭代这个过程*/
	        for( ; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        //当新元素大于空穴的父节点元素时，上述循环终止，将新元素放在空穴中，完成插入
			array[ hole ] = x;
	    }

- **删除最小元素deleteMin**：根据二叉堆的性质，最小元素就是根节点元素。删除它以后，在根节点建立一个空穴，然后检测堆中的最后一个元素（最底层的最右元素）放在空穴中是否会破坏堆序性质，若会破坏，则交换空穴与它的两个儿子中的较小者，这一步称之为**下滤**（空穴向下移动一层，其较小的儿子相应地向上填补位置），重复该步骤，直到最后一个元素可以被放到空穴中而不破坏堆序性质为止。平均而言，空穴要下滤到堆的最底层，因此平均花费O(logN)时间；最坏情况下，空穴也是要下滤到堆的最底层，因此最坏运行时间也是O(logN)。示例代码如下：

		//二叉堆的删除最小元素操作
		public AnyType deleteMin( ){
			//处理二叉堆为空的异常情况
	        if( isEmpty( ) )
	            throw new UnderflowException( );
			//找到最小元素（根元素）并删除
	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
			//执行下滤
	        percolateDown( 1 );
			//返回最小元素
	        return minItem;
	    }

		//执行下滤操作
		private void percolateDown( int hole ){
	        int child;
	        AnyType tmp = array[ hole ];
			//迭代进行下滤操作
	        for( ; hole * 2 <= currentSize; hole = child ){
	            child = hole * 2;
				//取左右儿子中较小的一个
	            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }

- **建堆buildHeap**：第一种方法是执行一连串的insert操作来建堆，这样每次insert之后都能保证堆序性质，它的平均运行时间是O(N)，而最坏情况是O(N * logN)。第二种方法是先将所有元素以任意顺序放入堆中（不保证堆序性质），然后对前半部分元素逐个执行下滤操作。可以证明，这种方法的运行时间界是O(N)。第二种方法的示例代码如下：

		//建堆操作
		private void buildHeap( ){
			//对前半部分元素逐个执行下滤操作
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

- **降低关键字的值decreaseKey**：在降低一个元素关键字的值后，可以通过上滤操作来使该元素上移，从而保证堆序性质。这一操作的应用场景为：管理员可以使某个程序以较高的优先级来运行（元素上移表示优先级升高，根节点的优先级最高）。
- **增加关键字的值increaseKey**：与decreaseKey相反，它可以通过下滤操作来调整堆序性质。其应用场景为：操作系统调度程序自动降低消耗过多资源的进程的优先级。
- **删除delete**：删除堆中某个特定的元素p，可以首先执行decreaseKey(p,∞)来将该元素上移至根节点处，再执行deleteMin完成删除。其应用场景为：用户强行中止了一个正在运行的进程，则该进程必须立即从优先队列中删除。
- **堆排序**：对一个包含N个元素的堆执行N次deleteMin操作，会得到排好序的元素，这种排序方式叫做堆排序，它执行的时间为N次deleteMin操作所花费的O(N * logN)加上建堆的时间O(N)，即O(N + N * logN)，比O(N * logN)略大。
- **最大堆与最小堆**：上述性质与操作针对的是**最小堆**，也即父元素 < 子元素的堆。此外也可以使用父元素 > 子元素的堆，称之为**最大堆**，最大堆的根节点是其最大元素，相应地，它没有deleteMin操作，而是deleteMax操作。

### d-堆 ###

- 二叉堆只允许一个节点最多有两个儿子，而**d-堆**是对二叉堆的简单扩展，它允许一个节点有d个儿子。d-堆是一棵完全d叉树，而二叉堆实质上是2-堆。
- d-堆的应用场景与B树和可扩散列类似，都是用来解决当数据量太大而装不进主存的情形的。当取较大的d时，d-堆的高度比二叉堆的高度要浅的多，因此可以减少磁盘访问次数。
- 由于d-堆是完全d叉树，因此也是非常有规律的，也可以简单地使用数组来实现。
- 实践证明：4-堆的效果要好于二叉堆。

### 左式堆、斜堆和二项队列 ###

- 由于二叉堆和d-堆的底层实现是简单的数组，因此执行两个堆的**合并**比较困难，因为这需要把一个数组拷贝到另一个数组中，并且每个元素都要找到合适的位置。事实上，所有支持高效合并操作的数据结构都应当使用链式数据结构。
- **左式堆**是非常不平衡的堆（严重左偏）。它执行合并操作的时间为O(logN)。
- **斜堆**是左式堆的自调节形式，斜堆与左式堆的关系类似于伸展树和AVL树之间的关系——斜堆执行合并操作的摊还时间为O(logN)。
- **二项队列**是由若干个满足堆序的树（**二项树**）所组成的**森林**。每一个高度上最多存在一棵二项树。高度为0的二项树是一棵单节点树；高度为k的二项树由一棵高度为k - 1的二项树附接到另一棵高度为k - 1的二项树的根上而构成。它执行合并操作效率更高，最坏情况下也仅需花费O(logN)时间。

### Java中的优先队列实现 ###

Java 1.5及更高版本包含了泛型类PriorityQueue，该类支持insert、findMin、deleteMin等操作（分别对应于add()、element()、remove()方法）。该类足够应付大多数优先队列的应用要求。


## 其他补充 ##

- **广义表**，参见[http://see.xidian.edu.cn/cpp/html/971.html](http://see.xidian.edu.cn/cpp/html/971.html)