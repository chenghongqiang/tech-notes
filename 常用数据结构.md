# 常用数据结构 #

本文包括数据结构的预备知识、表、栈、队列、树、散列、堆等常见数据结构的介绍

## 预备知识 ##

### 递归简论 ###

在编写递归函数时，要遵循如下准则：

- 必须要有**基准情形**，无需递归就可以解出。
- 每一次递归调用都必须要朝向一种基准情形推进，不能南辕北辙，导致递归永远无法结束。
- 假设所有的递归调用都能运行，也就是说不必试图追踪大量递归调用的细节，因为这往往很复杂。
- 切勿在不同的递归调用中做重复性的工作。

### 算法分析 ###

**分治策略**是一种常用的算法分析思想，“分”的阶段将问题拆分成两个大致相等的子问题，然后递归地进行求解；“治”的阶段将两个子问题的解合并起来，再做少量附加工作，从而得到整个问题的解。很多情况下，分治算法可以将原本耗费O(N)时间的算法减少到O(logN)时间。例如如下几个算法：

- **二分查找**：算法过程略。注意：该算法要求输入序列是排好序的。代码如下：
		
		public static <AnyType extends Comparable<? super AnyType>> 
		int binarySearch( AnyType [] a, AnyType x ){
			//初始化工作
	        int low = 0, high = a.length - 1;		
			//进行二分查找的迭代过程
	        while( low <= high ){
				//取中点元素
	            int mid = ( low + high ) / 2;
				//如果中点元素小于待查找元素，说明待查找元素在后半部分，迭代这个过程
	            if( a[ mid ].compareTo( x ) < 0 )
	                low = mid + 1;
				//如果中点元素大于待查找元素，说明待查找元素在前半部分，迭代这个过程
	            else if( a[ mid ].compareTo( x ) > 0 )
	                high = mid - 1;
	            //中点元素就是待查找元素，方法返回
				else
	                return mid;
	        }
			//若迭代循环结束，方法仍未返回，说明没有找到
	        return NOT_FOUND;
	    }

- **幂运算**：计算X的N次方，传统的算法是使用N-1次自乘，因此其花费时间是O(N)；而一种采用分治策略的递归算法效果更好——若N=0或1，直接算出结果，否则，若N是偶数，则`X^N = X^(N/2) * X^(N/2)`,只需递归求解`X^(N/2)`即可，若N是奇数，则`X^N = X^(N-1)/2 * X^(N-1)/2 * X`，只需递归求解`X^(N-1)/2`即可。可以看出，这种求幂运算的算法每次可以将问题的大小减半，因此该算法具有O(N)时间。代码如下：

		public static long pow( long x, int n ){
			//计算x的0次方，直接计算
	        if( n == 0 )
	            return 1;
			//计算x的1次方，直接计算
	        if( n == 1 )
	            return x;
			//若n为偶数（n>1），则递归计算x^2的n/2次方即可
	        if( isEven( n ) )
	            return pow( x * x, n / 2 );
			//若n为奇数（n>1），则递归计算x^2的n/2次方，再乘以x即可
	        else
	            return pow( x * x, n / 2 ) * x;
	    }


## 表 ##

### 基本概念及理论 ###

- 表有两种常用的实现方式：**顺序表**和**链表**，分别对应于Java容器API中的ArrayList和LinkedList。
- 对于顺序表ArrayList，其底层是数组实现的，因此ArrayList本质上相当于一个可增长数组。可增长机制的实现原理是：在创建ArrayList时先根据默认长度建立一个数组，在向ArrayList中添加元素时，若初始的数组长度已不够用，则创建一个新的数组（一般为原数组的两倍长），把原数组的元素都拷贝到新数组中，后续使用的就是这个长度扩大的新数组了。ArrayList可增长机制的实现代码如下所示：

		public void ensureCapacity( int newCapacity ){
			//容量未满，无需增大容量，直接返回
	        if( newCapacity < theSize )
	            return;
			//获得原数组
	        AnyType [] old = theItems;
			//建立容量扩大后的新数组
	        theItems = (AnyType []) new Object[ newCapacity ];
	        //将原数组中的内容拷贝至新数组中
			for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
		}

- 对于链表LinkedList，其底层实现需要一个嵌套的节点类Node，该嵌套类中包含数据域、前一节点和后一节点的引用（Node对象引用）。
- 对于随机访问操作，ArrayList的处理效率较高，因为它底层是数组实现的；而LinkedList的处理效率较低，因为它需要从链表的表头（或表尾）逐个元素进行访问，直到到达要访问的元素为止。ArrayList和LinkedList中的随机访问操作方法的实现代码如下所示：
	
		//ArrayList中的随机访问方法
		public AnyType get( int idx ){
			//若随机访问的下标越界，抛出异常
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
			//根据随机访问的下标直接返回数组元素
	        return theItems[ idx ];    
	    }

		//LinkedList中的随机访问方法
		private Node<AnyType> getNode( int idx, int lower, int upper ){
	        Node<AnyType> p;
	        //若随机访问的下标越界，抛出异常
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        //若随机访问的下标在前半部分，则从头节点开始，向后逐个访问，直到找到元素
	        if( idx < size( ) / 2 )
	        {
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
			//若随机访问的下标在后半部分，则从尾节点开始，向前逐个访问，直到找到元素
	        else
	        {
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        } 
	        //返回找到的元素
	        return p;
	    }
- 对于添加和删除操作，ArrayList的处理效率较低，因为在向数组的某个位置添加/删除元素时，需要将该位置之后的所有元素后移/前移一位；而LinkedList的处理效率较高，因为它只需适当调整该位置前、后节点的引用即可。ArrayList和LinkedList中的添加、删除操作方法的实现代码如下所示：

		//ArrayList中的添加方法
		public void add( int idx, AnyType x ){
			//若空间不够，扩大容量
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );
			//为了空出插入的位置，要将插入位置之后的所有元素后移一位
	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];
			//插入新元素
	        theItems[ idx ] = x;
			//List的长度加1
	        theSize++;  
	    }

		//ArrayList中的删除方法
		public AnyType remove( int idx ){
			//获取被删除的元素
	        AnyType removedItem = theItems[ idx ];
	        //将删除位置之后的所有元素前移一位
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
			//List的长度减1
	        theSize--;    
	        //返回被删除的元素
	        return removedItem;
	    }

		//LinkedList中的添加方法
		private void addBefore( Node<AnyType> p, AnyType x ){
			//创建要插入的新节点
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
			//接下来两行代码是调整新节点及其插入位置的前节点的相关引用，从而完成链表的插入
	        newNode.prev.next = newNode;
	        p.prev = newNode; 
			//List长度加1        
	        theSize++;
	    } 

		//LinkedList中的删除方法
		private AnyType remove( Node<AnyType> p ){
			//调整待删除节点的前、后节点的相关引用，使其绕过待删除节点，即可完成删除
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        //List长度减1
			theSize--;
	        //返回待删除元素
	        return p.data;
	    }
		
- ArrayList和LinkedList中都实现了迭代器Iterator，迭代器是一个内部类（之所以使用内部类，而不使用外部类或嵌套类，是因为内部类对象中包含了对外部类对象的隐式引用，因此不需要写额外的代码，迭代器就可以获取外部类List的引用，从而访问List中的元素）。
- 关于迭代器的使用，有两点需要注意：1、尽量使用迭代器的remove()方法，而不要使用List自身的remove()方法，因为List自身的remove()方法需要先找到该元素，然后删除；而迭代器的remove()方法直接删除游标指向的当前项。2、只有在需要立即使用一个迭代器的时候，才应该获取迭代器。因为如果对正在被迭代的容器进行结构上的改变（例如添加、删除等操作），则先前获取的迭代器将不再合法。


## 栈 ##

### 基本概念及理论 ###

- 栈是一种先进后出（FILO）的数据结构，它本质上是限制添加和删除操作只能在一个位置上（栈顶）进行的表，因此任何实现表的方法（例如ArrayList和LinkedList）都可以实现栈。
- 栈操作包括**入栈**push和**出栈**pop，这些操作都是在栈顶进行的，且都花费常数时间。

### 栈的应用 ###

- 编译器检查代码中的括号是否正确配对。
- 将中缀表达式转换成后缀表达式，并计算后缀表达式。（示例略）
- 方法调用（包括递归调用）。（注意：对于尾调用和尾递归，由于调用完成之后直接返回，没有后续操作了，因此无需在方法调用栈上添加新的栈帧，而仅仅更新原来的栈帧即可。所以编译器一般都会进行尾调用消除，来优化程序执行效率。）


## 队列 ##

### 基本概念及理论 ###

- 队列是一种先进先出（FIFO）的数据结构，它本质上也是表，因此任何实现表的方法（例如ArrayList和LinkedList）都可以实现队列。
- 队列的操作包括**插入**enqueue和**删除**dequeue。插入在队尾进行，删除在队头进行，均花费常数时间。
- 队列的数组实现会存在**假溢出**的问题，解决方法是将队列变成循环队列，当到达数组末端时重新绕回到开头。

### 队列的应用 ###

- 排队论
- 消息队列JMS


## 树 ##

### 基本概念及理论 ###

- 树的实现一般采用firstChild-nextSibling方法，即每个节点保存指向它的第一个儿子和它的右兄弟的链（由于事先不知道每个节点的儿子数目，因此直接保存指向所有儿子的链这种做法是不可行的，会产生太多浪费的空间）。
- 对于二叉树，由于每个节点最多有两个子节点，因此不必采用firstChild-nextSibling的实现方法，而可以直接保存指向子节点的链。

### 二叉查找树 ###

- 二叉查找树是非常重要的一种树，它的性质是:对于每一个节点，其左子树中所有项的值 < 该节点项的值 < 其右子树中所有项的值。因此二叉查找树是有序的。
- **contains方法**：在二叉查找树中查找某个元素是否存在，算法过程为：首先访问树的根节点，若待查找的值等于根节点的值，则找到返回；否则，若待查找的值小于/大于根节点的值，则对根节点的左子树/右子树进行递归的查找。该算法代码如下：

		private boolean contains( AnyType x, BinaryNode<AnyType> t ){
			//若当前节点为空，说明未找到，返回false
	        if( t == null )
	            return false;
	        //比较待查找的值与当前节点值
	        int compareResult = x.compareTo( t.element );
	        //若待查找的值小于当前节点值，则对当前节点的左子树进行递归查找
	        if( compareResult < 0 )
	            return contains( x, t.left );
			//若待查找的值大于当前节点值，则对当前节点的右子树进行递归查找
	        else if( compareResult > 0 )
	            return contains( x, t.right );
	        //若待查找的值等于当前节点值，则说明找到了
			else
	            return true;
	    }

- **findMin/findMax方法**：找到二叉查找树中的最小/最大元素，findMin算法过程为：从树的根节点开始，只要左儿子存在，就访问左儿子，直到终止。这个过程用递归和迭代都可以实现。findMax的算法过程与之类似。代码如下：

		//用递归的方法实现findMin
		private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t ){
			//若当前节点为null，说明是空树，返回null
	        if( t == null )
	            return null;
			//若当前节点没有左儿子，说明当前节点就是最小元素，返回之
	        else if( t.left == null )
	            return t;
			//若当前节点有左儿子，则递归地在左子树中查找
	        return findMin( t.left );
	    }

		//用迭代的方法实现findMax
		private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t ){
			//若当前节点不为空，则迭代地访问当前节点的右儿子，直到没有右儿子为止，此时该节点就是最大元素
	        if( t != null )
	            while( t.right != null )
	                t = t.right;
	        return t;
	    }

- **insert方法**：向二叉查找树中插入新元素。为了将元素插入到合适的位置，可以先使用contain方法进行查找，若找到，说明树中已经存在待插入的元素了，什么都不做即可；若没有找到，则将新元素插入到查找路径的终止点上（该终止点就是新元素应该在的位置）。代码如下：

		private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t ){
			//若当前节点为空，则直接创建新节点并返回
	        if( t == null )
	            return new BinaryNode<>( x, null, null );
	        //比较待插入元素值与当前节点的值
	        int compareResult = x.compareTo( t.element );
	        /*若待插入元素值小于当前节点的值，说明应该插入到当前节点的左子树上，因此在左子
			树上递归地调用insert方法，方法返回值为插入完成之后的左子树，用其更新原来的左子
			树*/
	        if( compareResult < 0 )
	            t.left = insert( x, t.left );
			/*若待插入元素值大于当前节点的值，说明应该插入到当前节点的右子树上，因此在右子
			树上递归地调用insert方法，方法返回值为插入完成之后的右子树，用其更新原来的右子
			树*/
	        else if( compareResult > 0 )
	            t.right = insert( x, t.right );
			//若待插入元素等于当前节点的值，说明待插入元素在树中已存在，则什么都不做
	        else
	            ;
			//最终返回完成插入操作之后的当前节点
	        return t;
	    }

- **remove方法**：从二叉查找树中删除指定的元素。需要分三种情况考虑：
	+ 待删除的节点没有儿子（也即它是一片树叶）：直接删除该节点即可。
	+ 待删除的节点有一个儿子：该节点可以在其父节点调整自己的链以绕过该节点后被删除。
	+ 待删除的节点有两个儿子：可以巧妙地化为第一种或第二种情况：用该节点的右子树中最小的元素（很容易找到）代替该节点，然后递归地删除右子树中最小的元素。由于右子树中最小的元素不可能有左儿子，因此它最多有一个儿子，所以问题转化为了前两种情况。
	+ remove方法的代码如下：
	
			private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t ){
				//若当前节点为空，则不需要删除，直接返回当前节点
		        if( t == null )
		            return t;
		        //比较待删除的元素值和当前节点值
		        int compareResult = x.compareTo( t.element );
		        /*若待删除的元素值小于当前节点值，说明待删除的元素在当前节点的左子树中，
				所以对左子树递归地调用remove方法*/
		        if( compareResult < 0 )
		            t.left = remove( x, t.left );
				/*若待删除的元素值大于当前节点值，说明待删除的元素在当前节点的右子树中，
				所以对右子树递归地调用remove方法*/
		        else if( compareResult > 0 )
		            t.right = remove( x, t.right );
				/*若待删除元素值等于当前节点值，说明当前节点就是待删除的元素，并且若当前
				节点有两个儿子，则符合上述第三种情况，首先用该节点的右子树中最小的元素代替
				该节点，然后递归地删除右子树中最小的元素*/
		        else if( t.left != null && t.right != null )
		        {
		            t.element = findMin( t.right ).element;
		            t.right = remove( t.element, t.right );
		        }
				/*若当前节点就是待删除的元素，并且当前节点只有零个或一个儿子，则符合上述
				前两种情况，进行相应操作即可*/
		        else
		            t = ( t.left != null ) ? t.left : t.right;
				//最终返回完成删除操作之后的当前节点
		        return t;
		    }

	+ 注意：上述的删除策略总是倾向于使左子树比右子树更深（因为第三种情况下，是使用右子树的最小元素来代替待删除节点，并最终递归删除右子树的最小元素，这会导致右子树的元素越来越少）。消除这种不平衡可以采用这种做法：每次删除时随机选取右子树的最小元素或左子树的最大元素来代替待删除节点，这样有时左子树的元素减少，有时右子树的元素减少，可以保证一定的平衡性。
	+ 除了上述的删除策略外，还可以采用**懒惰删除**，即被删除的节点仍旧留在树中，只是被标记为删除。

### AVL树 ###

- 普通的二叉查找树有可能会出现严重的不平衡，例如向一棵空树输入预先排好序的数据，则该树最终将退化成一个链表（所有的节点都只有右儿子，没有左儿子），从而导致该树深度太大，查找、插入等操作的效率很低。
- 为了解决普通二叉查找树的不平衡现象，有很多不同的实现方案，包括最古老的AVL树、伸展树、红黑树等等。
- AVL树是带有平衡条件的二叉查找树，它必须时刻保持树的平衡，也即保证树的深度是O(logN)。它需要满足的平衡条件是：其每个节点的左子树和右子树的高度最多相差1。
- 当向一棵AVL树插入元素时，有可能会破坏平衡条件，因此需要对插入之后的树进行修正，称之为**旋转**，旋转包括**单旋转**和**双旋转**，其中单旋转又包括**左旋转**和**右旋转**，双旋转包括先左旋转再右旋转，或先右旋转再左旋转。旋转的同时还应保持二叉查找树的特性（左儿子 < 节点 < 右儿子）。对于旋转操作的形象化理解，可以这样想象：把树看成是柔软灵活的，抓住作为旋转轴的节点，将其拎起来，在重力的作用下，该节点就成为了新的根节点。单旋转和双旋转的代码示例如下：

		//单旋转（左旋转）
		private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 ){
			//调整旋转涉及到的节点的链，从而完成旋转
	        AvlNode<AnyType> k1 = k2.left;
	        k2.left = k1.right;
	        k1.right = k2;
	        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
	        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
			//返回旋转完成之后的根节点（原来根节点的左儿子现在成为了新的根节点）
	        return k1;
	    }
		
		//单旋转（右旋转）
		private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 ){
			//调整旋转涉及到的节点的链，从而完成旋转
	        AvlNode<AnyType> k2 = k1.right;
	        k1.right = k2.left;
	        k2.left = k1;
	        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
	        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
			//返回旋转完成之后的根节点（原来根节点的右儿子现在成为了新的根节点）
	        return k2;
	    }

		//双旋转（先右旋转，再左旋转）
		private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 ){
			//先右旋转
	        k3.left = rotateWithRightChild( k3.left );
			//再左旋转
	        return rotateWithLeftChild( k3 );
	    }

		//双旋转（先左旋转，再右旋转）
		private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 ){
			//先左旋转
	        k1.right = rotateWithLeftChild( k1.right );
			//再右旋转
	        return rotateWithRightChild( k1 );
	    }

	向AVL树插入元素的示例代码如下：
		
		private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t ){
			//以下代码与普通二叉查找树的插入实现代码一样
	        if( t == null )
	            return new AvlNode<>( x, null, null );
	        int compareResult = x.compareTo( t.element );        
	        if( compareResult < 0 )
	            t.left = insert( x, t.left );
	        else if( compareResult > 0 )
	            t.right = insert( x, t.right );
	        else
	            ;

			//插入完成之后，要通过旋转操作进行修正，使AVL树重新满足平衡条件（balance方法代码略）
	        return balance( t );
	    }

	从AVL树中删除元素的示例代码如下：

		private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t ){
			//以下代码与普通二叉查找树的删除实现代码一样
	        if( t == null )
	            return t;     
	        int compareResult = x.compareTo( t.element );    
	        if( compareResult < 0 )
	            t.left = remove( x, t.left );
	        else if( compareResult > 0 )
	            t.right = remove( x, t.right );
	        else if( t.left != null && t.right != null ) // Two children
	        {
	            t.element = findMin( t.right ).element;
	            t.right = remove( t.element, t.right );
	        }
	        else
	            t = ( t.left != null ) ? t.left : t.right;

			//删除完成之后，要通过旋转操作进行修正，使AVL树重新满足平衡条件（balance方法代码略）
	        return balance( t );
	    }

### 伸展树 ###

伸展树的思路是：允许单次操作花费O(N)时间，但是每次访问一个节点之后，会将该节点上推到树根（通过一系列的旋转操作），使得该节点及其路径上的其他节点在下次访问时可以快很多。因此伸展树不保证每次操作都花费O(logN)时间，但是可以保证连续M次操作的总时间为O(M * logN)。也就是说，伸展树每次操作的**摊还代价**仍是O(logN)。伸展树的具体分析比较复杂，此处省略。

### 红黑树 ###

- 红黑树与AVL树类似，也是带有某些平衡条件的二叉查找树。它的每个节点上都有存储位表示节点颜色，可以是红色或黑色。
- 红黑树应满足的特性此处省略，但应记住：它的特性确保了树中没有一条路径会比其他路径长出一倍以上，因此红黑树是接近于平衡的。
- 在对红黑树进行插入和删除操作后，与AVL树类似，也需要进行旋转和重新着色等操作来修正该树。旋转包括左旋转和右旋转，与AVL树的左旋转和右旋转操作方式一样。
- 红黑树与AVL树的比较
	+ AVL树相对简单，红黑树比较复杂，尤其是红黑树的插入和删除操作，要考虑很多情况。
	+ AVL树是高度平衡的树（任一节点的左右子树高度差不能超过1），每一次对树的插入和删除操作都需要进行修正；红黑树的平衡程度要比AVL树略低（任意两个节点到根节点的路径相差不超过一倍），每次插入最多只需要两次旋转，删除最多只需要三次旋转。
	+ 由于AVL树是高度平衡的，因此其查找效率比较稳定；红黑树要略差一些。

- 红黑树的应用：
	+ 关联数组的实现
	+ Java中的TreeSet和TreeMap：这两种容器的底层实现都是红黑树，因此容器中的元素是有序的，并且组织树是接近平衡的，所以对TreeSet和TreeMap执行查找、插入和删除操作都只花费O(logN)时间。
	+ C++ STL中的set和map
	+ Linux中的虚拟内存管理

### 树的遍历 ###

树的遍历包括先序遍历（中左右）、中序遍历（左中右）、后序遍历（左右中），以及不常用的层序遍历。先序/中序/后序遍历的示例代码如下所示：

	//树的遍历的经典递归写法
	private void printTree( BinaryNode<AnyType> t ){
		//若当前节点不为空，则开始遍历
		if( t != null ){
			//接下来三行代码可以任意调整顺序，从而实现先序/中序/后序遍历。此处为中序遍历（左中右）
			printTree( t.left );
			System.out.println( t.element );
			printTree( t.right );
		}
	}

对于二叉查找树，执行一次中序遍历得到的是排好序的元素，这是排序算法的一种。
	
### B树 ###

- 上述讨论的所有种类的树都是放在主存中的。但是如果数据太多导致主存放不下，就需要将数据放在磁盘上。这时，影响树的操作效率的关键就不再是算法的时间复杂度了，而是对磁盘的I/O访问次数。相比一条算法指令的执行速度，对于磁盘的一次访问速度要慢的多，因此应该尽可能减少磁盘的访问次数。解决方法很简单：允许树有较多的分支，从而树的高度会降低，所以访问树中节点的磁盘I/O次数也会减少。
- B树就是这样的一种多叉树，它的具体特性此处省略。不过要注意：对于一棵B树，为了不让其退化成二叉树甚至是链表，应保证其任意节点（除根节点外）的儿子数至少要达到最大容量的一半，并且叶子节点存储的数据项个数也至少要达到最大容量的一半。
- 在对B树执行插入操作时，若数据项插入到的叶子节点已经满员，则需要将该叶子节点**分裂**成两个叶子节点；若此时该叶子节点的父节点也已满员，则继续分裂该父节点；以此类推，直至分裂到根节点。
- 在对B树执行删除操作时，若删除数据项之后，该叶子节点存储的数据项个数达不到最大容量的一半，则需要从相邻叶子节点**领养**元素。
- 插入时的分裂操作和删除时的领养操作都需要重新调整B树的结构，也即需要额外的磁盘I/O访问。但是经过一次分裂/领养之后，接下来的若干次插入/删除都无需再进行分裂/领养了，因此这点额外的代价是值得的。


## 散列 ##