# 《编程之美》读书笔记（三） #

结构之法——字符串及链表的探索

##3.1 字符串移位包含的问题##

###问题描述###

给定两个字符串s1和s2，要求判定s2是否能够被s1被循环移位得到的字符串包含。例如，给定s1=AABCD和s2=CDAA，返回true；给定s1=ABCD和s2=ACBD，返回false。

###解决思路###

####解法一####

最直接的方法，穷举s1做循环移位所能得到的所有字符串（分别右移1位、右移2位、……、右移n位得到），逐个考察s2是否被这些字符串所包含。判断一个字符串是否被另一个字符串所包含的函数为strstr()，这个算法需要调用n次strstr()函数。

####解法二####

通过观察可以发现，对s1做循环移位得到的字符串都必然是s1s1的子字符串（例如ABCD做任何循环移位得到的字符串都必然是ABCDABCD的子字符串）。因此如果s2被s1循环移位得到的字符串包含，那么s2一定被s1s1包含；反过来，若s2被s1s1包含，那么s2一定可以被s1循环移位得到的字符串包含。因此只需考察s2是否被s1s1包含，仅调用一次strstr()函数即可。


##3.2 电话号码对应英语单词##

###问题描述###

待补充

###解决思路###

待补充


##3.3 计算字符串的相似度##

###问题描述###

给定两个字符串，计算它们的**距离**。距离的定义：假如通过最少N次操作可以将字符串s1变为字符串s2，那么就称s1和s2的距离为N。另外，定义s1和s2之间的**相似度**为1/(N+1)。

例如，字符串“abcdefg”和“abcdef”之间的距离为1（前者删除一个“g”就可以变为后者，或者后者增加一个“g”就可以变为前者，因此最少需要一次操作）。

###解决思路###

- 考虑将原问题转变为规模较小的问题。假如有字符串A[1,2,……,k1]和字符串B[1,2,……,k2]，有以下两种情况：
	
	+ A和B的第一个字符相同，那么显然A和B的距离就等于A[2,……,k1]和B[2,……,k2]的距离。
	
	+ A和B的第一个字符不相同，那么有三种情况：

		- A和B的距离等于A[1,……,k1]和B[2,……,k2]的距离加上1（因为B[2,……,k2]可以通过一步操作变成B）；
		
		- A和B的距离等于A[2,……,k1]和B[1,……,k2]的距离加上1（因为A[2,……,k1]可以通过一步操作变成A）；
		
		- A和B的距离等于A[2,……,k1]和B[2,……,k2]的距离加上1（因为可以修改A的第一个字符为B的第一个字符，或者修改B的第一个字符为A的第一个字符，然后A和B的第一个字符就相同了，两者的距离就等于A[2,……,k1]和B[2,……,k2]的距离了，因此A和B的距离就等于A[2,……,k1]和B[2,……,k2]的距离加一步操作，即加1）；

		- 最后取以上三者的较小值即为A和B的距离。

- 根据以上算法写出代码如下：

		int CalculateStringDistance(string strA, int pABegin, int pAEnd, string strB, int pBBegin, int pBEnd){
			//分割线以上的部分为处理递归退出的情形
			//若strA为空串
			if(pABegin > pAEnd){
				//若strB也是空串，则strA和strB的距离为0
				if(pBBegin > pBEnd)
					return 0;
				//若strB不是空串，则strA和strB的距离即为strB的长度
				else
					return pBEnd - pBBegin + 1;
			}
			//若strB为空串
			if(pBBegin > pBEnd){
				//若strA也是空串，则strA和strB的距离为0
				if(pABegin > pAEnd)
					return 0;
				//若strA不是空串，则strA和strB的距离即为strA的长度
				else
					return pAEnd - pABegin + 1;
			}
			
			//==============================分割线=================================
			
			//若strA和strB的第一个字符相同，则递归地计算strA[2,……]与strB[2,……]的距离，即为strA与strB的距离
			if(strA[pABegin] == strB[pBBegin]){
				return CalculateStringDistance(strA, pABegin + 1, pAend, strB, pBBegin + 1, pBEnd);
			}	
			/*若strA和strB的第一个字符不同，则递归地计算strA与strB[2,……]的距离、
			strA[2,……]与strB的距离、strA[2,……]与strB[2,……]的距离。三者的较小值
			加上1即为strA和strB的距离*/
			else{
				int t1 = CalculateStringDistance(strA, pABegin, pAend, strB, pBBegin + 1, pBEnd);
				int t2 = CalculateStringDistance(strA, pABegin + 1, pAend, strB, pBBegin, pBEnd);
				int t3 = CalculateStringDistance(strA, pABegin + 1, pAend, strB, pBBegin + 1, pBEnd);	
				return min(t1, t2, t3) + 1;
			}
		}


##3.4 从无头单链表中删除节点##

###问题描述###

假设有一个没有头指针的单链表，如何删除这个单链表中的一个节点（该节点不是第一个，也不是最后一个节点）。

###解决思路###

- 如下图所示，假如要删除B节点，那么删除B节点本身容易，但由于是单链表且没有头指针，因此无法回溯到B的前一个节点A，也就无法将A和C相连。

![](http://i.imgur.com/J01vO6v.png)

- 解决方法是：我们不直接删除B，而是删除B的下一个节点C（删除C之后，把B和D重新连接起来很容易做到，因为无需回溯），然后**用C中的数据项取代B中的数据项**，那么最后的效果跟直接删除B就是一样的了。

###扩展问题###

####问题描述####

如何将一个单链表中的元素顺序反转？

####解决思路####

- 算法的中心思想是：从头节点开始顺序遍历所有节点，每次都把当前节点提到最前面来（与头节点相邻）。这一操作通过调整相应的链来实现。

- 举例来说，有一个单链表head -> a1 -> a2 -> a3 -> a4 -> ……

	+ 第一步，扫描到a1，它本来就是最前面的节点，无需操作；
	
	+ 第二步，扫描到a2，令head指向a2（即head指向pCurrent），a2指向a1（即pCurrent指向head->pNext），a1指向a3（即pCurrent->pPrevious指向pCurrent->pNext，其中pCurrent->pPrevious就是前一步结果中的pCurrent，可以在前一步存储下来），使得链表变为head -> a2 -> a1 -> a3 -> a4 -> ……

	+ 第三步，扫描到a3，令head指向a3（即head指向pCurrent），a3指向a2（即pCurrent指向head->pNext），a1指向a4（即pCurrent->pPrevious指向pCurrent->pNext），使得链表变为head -> a3 -> a2 -> a1 -> a4 -> …… 

	+ 如此逐个扫描链表中的元素，就可以完成单链表的反转。
 
- 除了这种算法之外，还可以借鉴从无头单链表中删除节点的方法：不用调整单链表中链的指向，而只需将各个节点的数据替换成反转之后的数据即可。具体做法：先顺序扫描一遍链表，将各节点的数据按顺序保存在一个数组中；然后将这个数组反转（很容易实现）；最后再顺序扫描一遍链表，依次将反转之后的数组元素赋给各节点。这个算法需要额外的空间和时间，但是比较简单，一目了然。


##3.5 最短摘要的生成##

###问题描述###

待补充

###解决思路###

待补充


##3.6 编程判断两个链表是否相交##

###问题描述###

给出两个单链表的头指针h1和h2，如何判断这两个链表是否相交？如下图所示。

![](http://i.imgur.com/FvkAVK5.png)

###解决思路###

通过思考可以知道这样一个事实：**如果两个单链表相交，那么它们的最后一个节点一定是共有的**。因此我们可以先遍历第一个链表，记下它的最后一个节点；然后遍历第二个链表，到最后一个节点时把它和第一个链表的最后一个节点做比较，如果两者相同则相交，否则不相交。


##3.7 队列中取最大值操作问题##

###问题描述###

假设有一个队列Queue，如何设计一种数据结构和算法，让队列的**取最大值**操作的时间复杂度尽可能的低。

###解决思路###

- 考虑到队列是一种“先进先出”的数据结构，它实现取最大值的操作需要遍历所有元素，时间复杂度为O(N)。而如果数据结构改用**最大堆**，就可以在O(1)时间内完成取最大值操作了。

- 根据上述思路，可以改变队列的底层实现——底层不用普通数组实现，而采用最大堆来实现。具体方法就是将队列中的元素以堆序性质组织（放入最大堆中），每个元素还需要维护一个额外的指针来记录队列的次序，如下图所示。

![](http://i.imgur.com/410giET.png)

- 以上算法的基本思想是：**一种数据结构的底层可以由另一种数据结构来实现**。

###扩展问题###

####问题描述####

如何用两个栈来实现一个队列？

####解决思路####

- 这个问题也是一个典型的“用一种数据结构来实现另一种数据结构”的问题。假设给定的是栈A和栈B，可以按如下操作分别执行入队和出队操作：

	+ 入队时，向栈B压入新元素即可。

	+ 出队时，判断栈A是否为空，若A是空栈，则依次将栈B中的元素出栈并压入栈A中，最后执行栈A的出栈操作，即可将最先入队（压入栈B）的元素弹出（最先压入栈B的元素位于栈B的最下面，它最后一个从栈B中出栈并被压入栈A，因此它在栈A中位于最上面），从而实现“先进先出”；若A不是空栈，则直接执行栈A的出栈操作即可，因为栈A的栈顶元素必然是最先压入栈B、并在后来从栈B中出栈并被压入栈A的元素，同样也实现了“先进先出”。

- 该实现方式的代码如下：

		class Queue{
			//使用两个栈
			private:
				stack stackA;
				stack stackB;
	
			public:
				//入队操作：向栈B中压入新元素即可
				EnQueue(v){
					stackB.push(v);
				}
				//出队操作：若栈A为空，则将栈B中的元素依次出栈并压入栈A中，最后执行栈A的出栈操作；若栈A不为空，则直接执行栈A的出栈操作
				Type DeQueue(){
					if(stackA.empty()){
						while(!stackB.empty()){
							stackA.push(stackB.pop());
						}
					}
					return stackA.pop();
				}
		}

##3.8 求二叉树中节点的最大距离##

###问题描述###

如何求一棵二叉树中相距最远的两个节点之间的距离？（两个节点之间的距离定义为两个节点之间边的个数）

###解决思路###

- 讨论k叉树的一般情形（二叉树是k=2的特殊情形）。假设相距最远的两个节点分别为U和V，那么U、V和根节点Root之间的关系有两种可能：

	+ 最远路径经过Root，则U和V一定属于Root的不同子树，且它们都是该子树中到Root最远的节点（否则跟它们相距最远相矛盾），如下图所示。

	![](http://i.imgur.com/7sDTjdT.png)

	+ 最远路径不经过Root，那么U和V一定属于Root的k个子树之一，并且它们也是该子树中相距最远的节点。从而原问题就可以转化为在某棵子树上的解，可以用动态规划来解决。如下图所示。

	![](http://i.imgur.com/goOWlDq.png)

- 根据以上分析，设第k棵子树中相距最远的两个节点为Uk和Vk，不妨令Uk为子树k中到子树根节点Rk距离最远的节点，设Uk到Rk的距离为dk，那么取dk中最大的两个值max1和max2，则**经过整棵树根节点Root**的最远路径为max1+max2+2；而**不经过整棵树根节点Root**的最远距离就是Uk和Vk距离的最大值（设为dkmax），可以递归地在k个子树上求解。因此整棵树中的最远距离就是max1+max2+2和dkmax两者中的较大者了。如下图所示。

![](http://i.imgur.com/qZRRhCn.png)

- 该算法的代码详见p244-p245。


##3.9 重建二叉树##

###问题描述###

假设已经有了一棵二叉树的前序遍历和中序遍历的结果，那么如何重建这棵二叉树呢？

###解决思路###

- 根据前序遍历和中序遍历的概念可以知道：前序遍历的每一个节点，都是当前子树的根节点。同时，以该节点为边界，就会把中序遍历的结果分为左子树和右子树。

- 例如：前序遍历结果为abdcef，中序遍历结果为dbaecf，那么可以按如下步骤分析：

	+ 前序遍历的第一个节点是a，因此它是根节点，它把中序遍历的结果分为两部分：左子树db和右子树ecf；
	
	+ 前序遍历的第二个节点是b，它是左子树（db）的根节点，它把中序遍历的结果（db）分为两部分：左子树d和右子树null；

	+ 如此逐个扫描前序遍历的节点，再根据中序遍历结果获取该节点的左子树和右子树，就可以重建二叉树了。

- 算法代码详见p248-p250。


##3.10 分层遍历二叉树##

###问题描述###

如何层序遍历一棵二叉树？要求每一层的节点访问顺序为从左至右，层与层之间要输出换行符。

###解决思路###

####解法一####

- 可以考虑编写一个函数，访问二叉树的某一层节点。于是我们从第一层到最后一层反复调用这个函数，就可以实现二叉树的层序遍历了。

- 访问二叉树的某一层节点的实现思路：假设要访问第k层节点，那么它等效于访问“根节点的左右子树的第k-1层节点”，也即访问“根节点的左右子树的左右子树的第k-2层节点”，……，这个过程可以用递归实现，代码如下所示。

		//打印第level层的节点，成功返回1，失败返回0，其中根节点为第0层
		int PrintNodeAtLevel(Node* root, int level){
			//失败情形
			if(!root || level < 0)
				return 0;
			//打印第0层，直接输出当前的根节点（不再递归）
			if(level == 0){
				cout << root->data << " ";
				return 1;
			}

			//递归地打印当前根节点的左子树和右子树的第level-1层
			return PrintNodeAtLevel(root->leftChild, level-1) + PrintNodeAtLevel(root->rightChild, level-1);
		}

- 有了上述访问某一层节点的函数，我们只需要知道二叉树的深度depth，就能够通过调用depth次PrintNodeAtLevel()函数来实现二叉树的层序遍历，代码如下：

		void PrintNodeByLevel(Node* root, int depth){
			//依次访问从第0到第depth-1层的节点
			for(int level = 0; level < depth; level++){
				PrintNodeAtLevel(root, level);
				cout << endl;
			}	
		}

- 以上层序遍历的代码还可以稍作改进：无需提供二叉树的深度就能完成层序遍历，代码如下：

		void PrintNodeByLevel(Node* root){
			for(int level = 0; ; level++){
				//从第0层开始逐层访问节点，当访问某一层节点失败时直接退出循环即可（说明该层不存在，所有层都已访问完毕）
				if(!PrintNodeAtLevel(root, level))
					break;
				cout << endl;
			}
		}

####解法二####

- 解法一中，每次调用PrintNodeAtLevel()函数打印某一层时，都需要重新从根节点开始递归，因此有很多重复计算。而事实上在访问第k层的时候，只需要知道第k-1层的节点信息就足够了，无需从根节点开始从头遍历。

- 根据上述分析，可以采用如下流程进行层序遍历：

	+ 从根节点出发，将当前层的所有节点从左至右压入一个数组中；

	+ 用一个游标Cur指示当前访问的节点，用另一个游标Last指示当前层次的最后一个节点的下一个位置；

	+ 以Cur==Last作为当前层次访问结束的条件，在访问某一层的同时将该层所有节点的子节点（也即下一层的节点）压入数组；

	+ 当前层次访问完毕后，更新Last游标，使其指向下一层的最后一个节点的下一个位置，准备开始下一层的访问；

	+ 直到不再有新节点可以访问，说明所有层次都已访问完毕，算法结束。

- 该算法代码如下：

		void PrintNodeByLevel(Node* root){
		    if(root == null)
				return;
			//使用STL中的vector（类似于Java中的List）取代数组，从而可以动态扩展其尺寸
			vector<Node*> vec;
		    vec.push_back(root);
		    int cur = 0;
			int last = 1;
			//访问每一层节点，直到不再有新节点可以访问为止（此时cur==vec.size()）
		    while(cur < vec.size()){
				//将游标last的值取为vec的长度，也即指向当前层次的最后一个节点的下一个位置
		        last = vec.size();
				//依次访问当前层次的节点（游标cur随之递增），当cur==last时说明当前层次已经访问完毕
		        while(cur < last){
					//打印当前访问到的节点（也即游标cur指向的节点）
		            cout << vec[cur]->data << " ";
		            //同时将当前访问到的节点的子节点压入vec中（如果子节点存在的话）
					if(vec[cur]->left)
		                vec.push_back(vec[cur]->left);
		            if(vec[cur]->right)
		                vec.push_back(vec[cur]->right);
		            cur++;
		        }
		        cout << endl;
		    }
		}


##3.11 程序改错##

###问题描述###

待补充

###解决思路###

待补充