# 《编程之美》读书笔记 #

本文记录在阅读《编程之美》时的心得、收获和总结

##1.1 让CPU占用率曲线听你指挥##

###问题描述###

- 使CPU占用曲线保持恒定（例如30%），呈一条直线。

- 令CPU占用曲线呈正弦曲线。

###解决思路###

- 一个程序在运行时，使得CPU闲下来（使用率为0%）的条件是该程序在等待用户输入、或等待某些事件的发生、或主动进入休眠状态（调用`Sleep()`函数）。

- 任务管理器的CPU占用曲线显示的是**每个刷新周期内**CPU占用率的**统计平均值**。

- 因此可以写一个程序，使它在任务管理器的一个刷新周期内一会儿忙，一会儿闲，然后调节忙/闲比例，就可以控制CPU占用曲线为一条特定的直线。

- 需要注意的是，应当在允许的范围内尽量减少sleep/awake（睡眠/唤醒）频率，以减少操作系统内核调度程序的频繁调度对CPU使用率的干扰；并且尽量不要调用系统函数，因为它也会导致不可控的内核运行时间，从而影响CPU使用率。

- 要使CPU占用曲线为正弦曲线，原理也是类似的：根据正弦曲线的函数表达式（`f(x)=sinx`），在特定的时间令CPU忙/闲比例为特定值即可。

##1.2 中国象棋将帅问题##

###问题描述###

中国象棋中“将”、“帅”两子（令“将”为A，“帅”为B）只能在本方3×3的格子里运动，要求写一个程序，输出A、B的所有可能位置组合，并且在代码中只能使用一个字节存储变量。

###解决思路###

- A和B理论上有3×3=9种可能的位置，再除去规则不允许的位置，实际可能的位置要少于9种。

- 在代码中只能使用一个字节来存储两个棋子的位置，可以采用8位的byte类型变量，用变量的前4bit存储A的位置，后4bit存储B的位置，由于4个bit可以表示16个数，因此这样就够用了。

- 延伸：bit级别的操作：
	+ 将一个变量（例如10100101）的右半部分（0101）设为某特定值n（例如0011）。做法是先清除该变量的右半部分（与11110000按位与，将右半部分全部清零），得到10100000；再将该结果与n（00000011）按位或，得到最终结果10100011。

	+ 将一个变量（例如10100101）的左半部分（1010）设为某特定值n（例如0011）。做法是先清除该变量的左半部分（与00001111按位与，将左半部分全部清零），得到00000101；然后将n左移4位，得到00110000；最后将以上两个结果按位或，得到最终结果00110101。

	+ 得到某一变量（例如10100101）的左半部分（1010）或右半部分（0101）。做法是将该变量与00001111进行按位与，得到右半部分（0101）；将该变量与11110000进行按位与，再将其右移4位，得到左半部分（1010）。

##1.3 一摞烙饼的排序##

###问题描述###

对于一摞烙饼，每次只允许翻转上面的一部分（将它们全部颠倒个个儿），求问这样如何将原本无序的烙饼按形状排好序？

###解决思路###

- 基本的解决思想是：首先找到最大的一个饼，将该饼连同其之上的所有饼翻转一次（这样最大的这个饼就被翻到最上面了）；然后把所有的n个烙饼翻转，这样就把最大的烙饼放在最底下了；接着对剩下的n-1个饼重复该过程，就能完成排序了。

- 算法分析：以上算法中，每循环一次该过程，就需要翻转两次（把最大的翻上去，再全部翻转一次），因此一共需要2(n-1)次翻转。

- 算法优化：除了以上翻转策略外，还可以采用动态规划方式考察所有的翻转策略，找出所需翻转次数最少的策略。考察每种策略退出的条件为：烙饼已经完成排序，或者尚未完成排序但翻转次数已经超过2(n-1)了（因为这样就肯定不是最优策略了）。

##1.4 买书问题##

###问题描述###

待补充

###解决思路###

待补充

###背景知识——动态规划###

- 动态规划算法的基本思想与分治算法类似，也是将待求解的问题分解为若干个子问题（阶段）。但是动态规划算法与分治算法的最大差别在于：动态规划算法的子问题之间往往不是相互独立的（下一阶段子问题的求解是建立在上一阶段子问题的解之上的）；而分治算法的子问题之间一般都是相互独立、互不影响的。

- 适用动态规划算法的问题一般应满足**最优化原理**（整个问题的最优解所包含的子问题的解也是最优的）和**无后效性**（即某阶段的状态一旦确定，就不受这个状态之后决策的影响）。

- 动态规划算法的求解，最主要的是确定**状态转移方程**，来表示从前一个阶段转化到后一个阶段的递推关系。整个动态规划的求解过程可以用一个二维的**最优决策表**来描述，其中行表示决策的每一个阶段，列表示每一个状态。表中存储的是某个阶段某个状态下的最优解。填表的过程就是根据状态转移方程描述的递推关系，从第1行第1列开始依次填写表格。最后根据整个表格中的数据得到整个问题的最终解。

- 动态规划算法的详细资料及算法示例参见[http://blog.csdn.net/v_JULY_v/article/details/6110269](http://blog.csdn.net/v_JULY_v/article/details/6110269)。

##1.5 快速找出故障机器##

###问题描述###

1. 在一个序列中有很多ID，每个ID均出现了两次。现在丢失了其中的一个ID（也即该ID现在只出现了一次），求问如何找出这个丢失的ID？

2. 在问题1的序列中，若丢失了其中的两个ID呢？如何找到这两个丢失的ID？

###解决思路###

####问题1的解法####

1. 解法一：采用**异或**的方式。将序列中的所有ID进行异或操作，由于其余每个ID均出现两次，而X⊕X=0、X⊕0=X，并且异或满足交换律和结合率，因此所有ID的异或值就等于仅出现一次的那个ID，也就是丢失的那个ID。

2. 解法二：预先计算好序列中所有ID的和（丢失ID之前），再计算丢失ID之后序列中其余所有ID之和，这两者之差就是丢失的那个ID。

####问题2的解法####

1. 解法一：采用**异或**的方式。设这两个丢失的ID分别为A和B，那么将所有ID异或后得到的值为A⊕B，分两种情况讨论：
	
	+ 若A⊕B=0，说明A=B，也即丢失的两个是同一个ID，则可以采用求和的方式，计算丢失之前和丢失之后的ID和之差，再除以2即为丢失的ID。
	
	+ 若A⊕B!=0，说明A和B是两个不同的ID，那么这个异或值的二进制中的某一位等于1，这意味着A和B中有且仅有一个数的相应位上也是1。进一步，我们可以将所有ID分为两类，一类在这一位上等于1，另一类在这一位上等于0。这两类分别包含A和B中的一个，于是该问题转化为了问题1（序列中包含一个丢失的ID），这时分别对这两类序列进行异或操作，即可求得A和B的值。

2. 解法二：与问题1的解法二类似，设这两个丢失的ID分别为A和B，用预先计算好的序列中所有ID之和减去丢失之后剩余ID之和，即得到A+B的值。此时有两个未知数，但只有一个方程，我们可以再构造一个方程，例如A^2+B^2（计算丢失前/丢失后所有ID的平方和之差），然后解这个二元方程组，就可以求得A和B的值了。

####注意####

- 以上提供的解法时间复杂度为O(N)（需要线性遍历一遍序列），空间复杂度为O(1)（仅需存储异或值、和值、平方和值等几个变量），已经是最优算法。

- 若将问题再做扩展，寻找丢失的N个ID，可以遵循问题2的解法二的思路，构造N元方程组，提供N个方程（例如立方和、四次方和等等），即可解决。

##1.6 饮料供货问题##

###问题描述###

待补充

###解决思路###

待补充

##1.7 光影切割问题##

###问题描述###

![](http://i.imgur.com/p17t8NF.png)

如图所示，如何计算仓库地板被光影总共划分为多少块？

###解决思路###

- 根据观察并总结数学规律可以得出结论：被光影划分的块数=N+M+1，其中N为光线个数，M为光线之间的交点个数。

- 光线个数N很容易获得，而光线之间的交点个数M的求解方法可以转化为对序列逆序数的求解。如下图所示：令三条光线与左边界的交点为有序序列（a,b,c），则与右边界的交点为无序序列（c,b,a），该序列的逆序数为3，也即光线之间的交点个数为3。该结论可以表述如下：交点个数等于一个边界上的交点顺序相对于另一个边界上交点顺序的逆序总数。

![](http://i.imgur.com/66YnLRp.png)

- **逆序数的求解**方法与归并排序算法类似，采用分治思想：

	+ 首先递归地求解前N/2个元素的逆序数和后N/2个元素的逆序数。

	+ 然后合并前后两部分的逆序数。总的逆序数=前半部分逆序数（可递归求出）+后半部分逆序数（可递归求出）+前后两部分元素之间的逆序数。

	+ 前后两部分元素之间的逆序数的求解方法为：将前半部分（设为seq1）和后半部分（设为seq2）采用归并排序进行合并（注意由于采用归并排序，所以此时seq1和seq2已经递归地排好序了）。假设归并排序在seq1设置的游标为i，在seq2设置的游标为j，则若seq1[i]<=seq2[j]，则没有逆序；若seq1[i]>seq2[j]，则说明seq1中位于seq1[i]之后的所有元素都大于seq2[j]，则逆序数为“seq1中位于seq1[i]之后的元素个数”。如此随着游标i、j的不断右移，将得到的逆序数累加起来，就能得出前后两部分元素之间的逆序总数。

	+ 这种求逆序数的方式实际上是在归并排序的过程中“顺便”求得了逆序数。

##1.8 小飞的电梯调度算法##

###问题描述###

假设一栋大楼里的电梯只能停在第x层，所有的乘客都需要乘电梯坐到x层后步行上楼/下楼走到自己的目的楼层，请问x应当取何值能够保证所有乘客爬楼梯的层数之和最小？

###解决思路###

####解法一####

简单的穷举法：从第一层开始枚举直到最高层，对每一层计算出如果电梯停在该层则所有乘客要爬多少层楼梯，取最小值及相应楼层即为最终解。

该方法包含两个for循环，外层循环遍历每一层；内层循环遍历当电梯停在该层时，要去其余各个楼层的乘客数目。因此该算法时间复杂度为O(N^2)。

####解法二####

假设电梯停在i层楼，设N1个乘客的目的楼层在i层以下、N2个乘客的目的楼层在i层、N3个乘客的目的楼层在i层以上。考虑以下两种情况：
	
+ 若电梯改停在i-1层，则位于i层以下的N1个乘客可以少爬一层，位于i层及以上的N2+N3个乘客要多爬一层，因此要多爬（N2+N3-N1）层。

+ 若电梯改停在i+1层，则位于i层及以下的N1+N2个乘客要多爬一层，位于i层以上的N3个乘客可以少爬一层，因此要多爬（N1+N2-N3）层。

根据上述分情况讨论，可以得出下列结论：

+ 若N2+N3<N1，则停在i-1层更好。

+ 若N1+N2<N3，则停在i+1层更好。

+ 其余情况下，停在i层更好。

根据以上分析，可以写出代码如下：

	int nPerson[]; //nPerson[i]表示目的楼层为第i层的乘客数目
	int nMinFloor, nTargetFloor; //nMinFloor为最小的爬楼梯总层数，nTargetFloor为相应的楼层
	int N1, N2, N3;

	nTargetFloor = 1;
	nMinFloor = 0;
	
	//初始化（计算电梯停在第一层时的各变量值，包括N1、N2、N3、nMinFloor）
	for(N1=0, N2=nPerson[1], N3=0, i=2;   i<=N;   i++){
		N3+=nPerson[i];
		nMinFloor += nPerson[i]*(i-1);
	}
	
	//从第二层开始，依次计算第2、3、4、...层的相关变量值
	for(i=2; i<=N; i++){
		//若N1+N2<N3，则根据上述结论，停在第i+1层更好，更新相关变量为第i+1层的情形，循环继续
		if(N1+N2<N3){
			nTargetFloor = i;
			nMinFloor += (N1+N2-N3);
			N1+=N2;
			N2=nPerson[i];
			N3-=nPerson[i];
		}
		//否则停在当前层（第i层）最好，直接退出循环
		else 
			break;
	}
	//返回结果
	return (nTargetFloor, nMinFloor);

注意，对于上述程序可能会有如下疑问：假如当前停在第i层，循环一次后，若第i+1层比第i层要坏，则循环直接退出了，那么有没有可能第i+2层（或更高层）比第i层更好，从而被遗漏掉了呢？答案是否定的，简单地列式计算一下即可。

##1.9 高效率地安排见面会##

###问题描述###

已知有n位学生，m个研究组，其中每个学生都对若干个研究组感兴趣。现在要安排学生参与自己感兴趣研究组的见面会，假设每个见面会的时长为t，那么如何安排才能使得所有见面会的总时长最短？

###解决思路###

- 该问题可以如下抽象：把每个研究组看成一些散布的点，如果有一位同学同时对两个研究组感兴趣，则在这两个研究组对应的点之间加上一条边；如果有同学同时对k个研究组感兴趣，那么这k个研究组对应的点两两之间都要加上一条边。于是该问题就抽象为了**最少着色问题**。

- **最少着色问题**指的是，对于一个无向图G(E,V)，试用最少的颜色为这个图的顶点着色，使得∀(vi,vj)∈E，有vi和vj的颜色不同。（对应于我们的问题，也就是说只要有同学对某两个研究组感兴趣，那么相应的两点之间就有一条边，我们就应该把这两个研究组的见面会安排在不同的时间，也即着上不同的颜色）

- 最少着色问题至今没有有效的算法，有待深入研究。