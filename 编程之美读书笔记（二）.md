# 《编程之美》读书笔记（二） #

数字之魅——数字中的技巧

##2.1 求二进制数中1的个数##

###问题描述###

对于一个字节（8bit）的无符号整型变量，求其二进制表示中“1”的个数，要求算法执行效率尽可能的高。

###解决思路###

####解法一####

对于二进制数来说，可以将其**除以2并求余数**来判断末位是0还是1。以10100101为例，第一次除以2时余数为1，说明该位为1；继续除以2，余数为0，说明该位为0。代码如下：

	int Count(BYTE v){
		int num = 0;
		while(v){
			//除以2，判断余数，余数为1则说明末位为1
			if(v % 2 == 1){
				num++;
			}
			//保存商，为下一次循环做准备
			v = v/2;
		}
		return num;
	}

####解法二####

上述解法中的**除以2**操作，在二进制数中可以用**右移一位**来代替。例如对于10100001来说，首先将其与00000001**相与**，结果为1，说明当前末位为1；然后右移一位，继续与00000001相与……。这种解法使用**右移**+**与操作**替代了解法一的**除以2**+**求余**操作。

####解法三####

由于问题仅涵盖8位的整数（0——255之间），因此可以预先将这256个数中“1”的个数存储起来，例如存储到一个长度为256的数组中，在求解时无需计算，直接返回答案。

这种算法是典型的**空间换时间**的思想。

##2.2 不要被阶乘吓倒##

###问题描述###

1. 给定一个整数，求解N的阶乘N!的末尾有多少个0？例如：N=10，N!=3628800，末尾有2个0。

2. 求N!的二进制表示中最低位1的位置。

###解决思路###

####问题1####

- 求解阶乘N!的末尾有多少个0，可以转化为以下问题：对于N!=K×10^M，且K不能被10整除，求解M的值。

- 更进一步，可以对N!进行质因数分解N!=(2^X)×(3^Y)×(5^Z)×……，由于2×5=10，所以M只与X和Z相关，每一对2和5相乘可以得到一个10，于是M=min(X,Z)。

- 再进一步，由于能被2整除的数要比能被5整除的数要多，所以M=Z。因此只要求出Z的值，也就是N!的质因数分解中5的个数，就能得到N!中末尾0的个数。

- 根据以上思路，写出代码如下：

		ret = 0;
		for(i = 1; i <= N; i++){
			j = i;
			//循环每进行一次，说明找到一个质因数5，ret值增1
			while(j % 5 == 0){
				ret++;
				j /= 5;
			} 
		}

####问题2####

- 求解N!的二进制表示中最低位1的位置，可以转化为求解N!含有质因数2的个数。（因为假如最低位1在第M位，那么说明更低的M-1位都是0，因此说明该数包含M-1个质因数2）

- 求解质因数2的个数可以采用问题1的解法。另外注意：“除以2”操作可以用“右移一位”操作来代替。

##2.3 寻找发帖“水王”##

###问题描述###

如果一个列表中，某个值的出现次数超过了列表总长度的一半，那么如何快速找到这个值？

###解决思路###

- 比较简单的方法：可以先将列表排序，由于这个值出现了超过一半的次数，那么这个列表**正中间**的一项一定是这个值，直接返回该值即可。这种算法需要先排序（花费至少O(N*logN)时间），然后再用O(1)时间返回结果。

- 效率更高的方法：每次删除两个**不相同**的值（不管是否包含要找的这个值），那么，在列表中剩下的值中，要找的这个值出现的次数仍然会超过一半。可以不断重复这个过程，把列表中的元素总数降低（转化为更小的问题）。这样对列表只需进行一趟遍历就能找到这个值，所需时间为O(N)。

- 第二种解法里，把原问题转化为规模较小的子问题的思想在计算机科学中非常普遍，分治算法、动态规划算法、递归算法、贪心算法等等都基于这种思想。

##2.4 1的数目##

###问题描述###

给定一个十进制正整数N，写下从1开始到N的所有整数，然后求出其中出现“1”的次数。例如N=12，写下1,2,3,4,5,6,7,8,9,10,11,12，其中“1”的次数为5。

###解决思路###

- 可以从简单的情形开始分析观察，总结其中的**数学规律**，加以推广的一般情形。

- 对于此题来说，可以先考察1位数的情况、再考察2位数的情况、接着考察3位数的情况……最终推广到一般情形。

##2.5 寻找最大的K个数##

###问题描述###

假设有N个无序的数，如何找出其中最大的K个数呢？

###解决思路###

####解法一——部分冒泡排序####

由于冒泡排序每趟会把最大的元素“沉底”，因此可以执行K趟冒泡，把前K个大的数“沉底”，从而找到最大的K个数。这种方法不必执行完整的冒泡排序，时间复杂度为O(N*K)。

####解法二——快速选择####

- 快速选择的思想取自快速排序算法，将集合分为枢纽元、左半部分（其中元素均大于枢纽元）和右半部分（其中元素均小于枢纽元），从而递归完成排序。

- 用快速选择法找出最大的K个数的算法如下：

	+ 假设K个数存储在数组S中，我们从数组S中随机找出一个元素X（枢纽元），把数组分成两部分Sa和Sb，其中Sa中的元素大于等于X，Sb中的元素小于X。此时有两种可能性：

		1. Sa中的元素个数小于K，那么最大的K个数 = Sa中的全部元素 + Sb中最大的K-|Sa|个元素。
		
		2. Sa中的元素个数大于等于K，那么最大的K个数 = Sa中最大的K个数。
	
	+ 无论是以上哪种情形，接下来都需要递归地在Sa或Sb中找到最大的若干个数，最终通过递归实现求解。

- 快速选择法的伪代码如下：

		//函数Kbig用于找到集合S中最大的k个数
		Kbig(S, k):
			if(k <= 0)
				return [];
			if(S.length <= k)
				return S;
			//首先调用函数Partition()，将S分为Sa和Sb两部分，其中Sa中的元素均大于Sb中的元素
			(Sa, Sb) = Partition(S);
			/*然后有两种情况：
				1、Sa的大小小于k，则返回Sa中全部元素，加上Sb中的前k-|Sa|个元素
				2、Sa的大小大于等于k，则返回Sa中的前k个元素
			  以下代码将上述两种情况统一为了同一种递归写法*/
			return Kbig(Sa, k).append(Kbig(Sb, k-Sa.length));

		//函数Partition用于将集合S分成Sa、Sb两部分，其中Sa中的元素均大于Sb中的元素
		Partition(S):
			Sa=[]; Sb=[];
			//随机选取枢纽元p
			p = S[random];
			//对于集合S中除了p之外的其他元素，若大于p则放入Sa中，否则放入Sb中
			for i in S except p:
				S[i] > p ? Sa.append(S[i]) : Sb.append(S[i])
			//最后将枢纽元本身也放入Sa或Sb中
			Sa.length < Sb.length ? Sa.append(p) : Sb.append(p);
			//返回分好的两个子集Sa、Sb
			return (Sa, Sb); 

- 快速选择法的平均时间复杂度为O(N*logK)。

####解法三——使用最小堆####

- 使用一个容量为K的**最小堆**，首先把集合前K个数依次放入堆中并保持堆序，此时集合中还剩下N-K个数。

- 逐个把剩下的N-K个数放入堆中，对于每个新到来的数，分两种情况讨论：

	+ 若这个数小于堆顶元素，说明这个数比堆中所有的K个数都小，那么它肯定不属于最大的K个数之列，所以摒弃这个数。

	+ 若这个数大于堆顶元素，那么这个数有可能属于最大的K个数之列。用它来替换堆顶元素（将原来的堆顶元素摒弃），这时堆序性质可能会被破坏，需要通过“下滤”操作来调整并保持堆序性质。

- 当把剩下的N-K个数逐个扫描之后，算法结束，此时堆中的K个数就是集合中最大的K个数。

- 上述算法中，每次新元素的“下滤”操作平均花费时间为O(logK)，因此算法总时间为O(N*logK)（包括建堆的时间）。

####解法四——桶式排序####

若集合中的数都是位于[0, MAXN]之间的正整数，则可以采用桶式排序，排序之后返回前K个元素即可。