# 《编程之美》读书笔记（二） #

数字之魅——数字中的技巧

##2.1 求二进制数中1的个数##

###问题描述###

对于一个字节（8bit）的无符号整型变量，求其二进制表示中“1”的个数，要求算法执行效率尽可能的高。

###解决思路###

####解法一####

对于二进制数来说，可以将其**除以2并求余数**来判断末位是0还是1。以10100101为例，第一次除以2时余数为1，说明该位为1；继续除以2，余数为0，说明该位为0。代码如下：

	int Count(BYTE v){
		int num = 0;
		while(v){
			//除以2，判断余数，余数为1则说明末位为1
			if(v % 2 == 1){
				num++;
			}
			//保存商，为下一次循环做准备
			v = v/2;
		}
		return num;
	}

####解法二####

上述解法中的**除以2**操作，在二进制数中可以用**右移一位**来代替。例如对于10100001来说，首先将其与00000001**相与**，结果为1，说明当前末位为1；然后右移一位，继续与00000001相与……。这种解法使用**右移**+**与操作**替代了解法一的**除以2**+**求余**操作。

####解法三####

由于问题仅涵盖8位的整数（0——255之间），因此可以预先将这256个数中“1”的个数存储起来，例如存储到一个长度为256的数组中，在求解时无需计算，直接返回答案。

这种算法是典型的**空间换时间**的思想。

##2.2 不要被阶乘吓倒##

###问题描述###

1. 给定一个整数，求解N的阶乘N!的末尾有多少个0？例如：N=10，N!=3628800，末尾有2个0。

2. 求N!的二进制表示中最低位1的位置。

###解决思路###

####问题1####

- 求解阶乘N!的末尾有多少个0，可以转化为以下问题：对于N!=K×10^M，且K不能被10整除，求解M的值。

- 更进一步，可以对N!进行质因数分解N!=(2^X)×(3^Y)×(5^Z)×……，由于2×5=10，所以M只与X和Z相关，每一对2和5相乘可以得到一个10，于是M=min(X,Z)。

- 再进一步，由于能被2整除的数要比能被5整除的数要多，所以M=Z。因此只要求出Z的值，也就是N!的质因数分解中5的个数，就能得到N!中末尾0的个数。

- 根据以上思路，写出代码如下：

		ret = 0;
		for(i = 1; i <= N; i++){
			j = i;
			//循环每进行一次，说明找到一个质因数5，ret值增1
			while(j % 5 == 0){
				ret++;
				j /= 5;
			} 
		}

####问题2####

- 求解N!的二进制表示中最低位1的位置，可以转化为求解N!含有质因数2的个数。（因为假如最低位1在第M位，那么说明更低的M-1位都是0，因此说明该数包含M-1个质因数2）

- 求解质因数2的个数可以采用问题1的解法。另外注意：“除以2”操作可以用“右移一位”操作来代替。

##2.3 寻找发帖“水王”##

###问题描述###

如果一个列表中，某个值的出现次数超过了列表总长度的一半，那么如何快速找到这个值？

###解决思路###

- 比较简单的方法：可以先将列表排序，由于这个值出现了超过一半的次数，那么这个列表**正中间**的一项一定是这个值，直接返回该值即可。这种算法需要先排序（花费至少O(N*logN)时间），然后再用O(1)时间返回结果。

- 效率更高的方法：每次删除两个**不相同**的值（不管是否包含要找的这个值），那么，在列表中剩下的值中，要找的这个值出现的次数仍然会超过一半。可以不断重复这个过程，把列表中的元素总数降低（转化为更小的问题）。这样对列表只需进行一趟遍历就能找到这个值，所需时间为O(N)。

- 第二种解法里，把原问题转化为规模较小的子问题的思想在计算机科学中非常普遍，分治算法、动态规划算法、递归算法、贪心算法等等都基于这种思想。

##2.4 1的数目##

###问题描述###

给定一个十进制正整数N，写下从1开始到N的所有整数，然后求出其中出现“1”的次数。例如N=12，写下1,2,3,4,5,6,7,8,9,10,11,12，其中“1”的次数为5。

###解决思路###

- 可以从简单的情形开始分析观察，总结其中的**数学规律**，加以推广的一般情形。

- 对于此题来说，可以先考察1位数的情况、再考察2位数的情况、接着考察3位数的情况……最终推广到一般情形。

##2.5 寻找最大的K个数##

###问题描述###

假设有N个无序的数，如何找出其中最大的K个数呢？

###解决思路###

####解法一——部分冒泡排序####

由于冒泡排序每趟会把最大的元素“沉底”，因此可以执行K趟冒泡，把前K个大的数“沉底”，从而找到最大的K个数。这种方法不必执行完整的冒泡排序，时间复杂度为O(N*K)。

####解法二——快速选择####

- 快速选择的思想取自快速排序算法，将集合分为枢纽元、左半部分（其中元素均大于枢纽元）和右半部分（其中元素均小于枢纽元），从而递归完成排序。

- 用快速选择法找出最大的K个数的算法如下：

	+ 假设K个数存储在数组S中，我们从数组S中随机找出一个元素X（枢纽元），把数组分成两部分Sa和Sb，其中Sa中的元素大于等于X，Sb中的元素小于X。此时有两种可能性：

		1. Sa中的元素个数小于K，那么最大的K个数 = Sa中的全部元素 + Sb中最大的K-|Sa|个元素。
		
		2. Sa中的元素个数大于等于K，那么最大的K个数 = Sa中最大的K个数。
	
	+ 无论是以上哪种情形，接下来都需要递归地在Sa或Sb中找到最大的若干个数，最终通过递归实现求解。

- 快速选择法的伪代码如下：

		//函数Kbig用于找到集合S中最大的k个数
		Kbig(S, k):
			if(k <= 0)
				return [];
			if(S.length <= k)
				return S;
			//首先调用函数Partition()，将S分为Sa和Sb两部分，其中Sa中的元素均大于Sb中的元素
			(Sa, Sb) = Partition(S);
			/*然后有两种情况：
				1、Sa的大小小于k，则返回Sa中全部元素，加上Sb中的前k-|Sa|个元素
				2、Sa的大小大于等于k，则返回Sa中的前k个元素
			  以下代码将上述两种情况统一为了同一种递归写法*/
			return Kbig(Sa, k).append(Kbig(Sb, k-Sa.length));

		//函数Partition用于将集合S分成Sa、Sb两部分，其中Sa中的元素均大于Sb中的元素
		Partition(S):
			Sa=[]; Sb=[];
			//随机选取枢纽元p
			p = S[random];
			//对于集合S中除了p之外的其他元素，若大于p则放入Sa中，否则放入Sb中
			for i in S except p:
				S[i] > p ? Sa.append(S[i]) : Sb.append(S[i])
			//最后将枢纽元本身也放入Sa或Sb中
			Sa.length < Sb.length ? Sa.append(p) : Sb.append(p);
			//返回分好的两个子集Sa、Sb
			return (Sa, Sb); 

- 快速选择法的平均时间复杂度为O(N*logK)。

####解法三——使用最小堆####

- 使用一个容量为K的**最小堆**，首先把集合前K个数依次放入堆中并保持堆序，此时集合中还剩下N-K个数。

- 逐个把剩下的N-K个数放入堆中，对于每个新到来的数，分两种情况讨论：

	+ 若这个数小于堆顶元素，说明这个数比堆中所有的K个数都小，那么它肯定不属于最大的K个数之列，所以摒弃这个数。

	+ 若这个数大于堆顶元素，那么这个数有可能属于最大的K个数之列。用它来替换堆顶元素（将原来的堆顶元素摒弃），这时堆序性质可能会被破坏，需要通过“下滤”操作来调整并保持堆序性质。

- 当把剩下的N-K个数逐个扫描之后，算法结束，此时堆中的K个数就是集合中最大的K个数。

- 上述算法中，每次新元素的“下滤”操作平均花费时间为O(logK)，因此算法总时间为O(N*logK)（包括建堆的时间）。

####解法四——桶式排序####

若集合中的数都是位于[0, MAXN]之间的正整数，则可以采用桶式排序，排序之后返回前K个元素即可。

##2.6 精确表达浮点数##

###问题描述###

待补充

###解决思路###

待补充

##2.7 最大公约数问题##

###问题描述###

求解两个正整数的最大公约数（Greatest Common Divisor，GCD）

###解决思路###

####解法一——辗转相除法####

- 假设用f(x,y)来表示x和y的最大公约数（其中x>=y），那么取k=x/y，b=x%y，则x=ky+b。如果一个数能够同时整除x和y，那么它一定可以同时整除b和y；另一方面，如果一个数能够同时被b和y整除，那么它一定可以同时被x和y整除。也就是说，x和y的公约数与b和y的公约数是相同的，其最大公约数也是相同的，也即满足`f(x,y) = f(x%y,y)`。这样便可以把原问题转化为求两个更小的数的最大公约数，直到其中一个数为0，则另一个数就是两者的最大公约数。

- 辗转相除法的示例：f(42,30) = f(30,12) = f(12,6) = f(6,0) = 6.

- 辗转相除法的代码：

		int gcd(int x, int y){
			//若y等于0，则x就是最大公约数；若y不等于0，则继续递归调用gcd(y, x%y)
			return (!y) ? x : gcd(y, x%y);
		}

- 算法缺点：如果遇到大整数，则求余操作开销较大。

####解法二——“类”辗转相除法####

- 借鉴解法一的分析，可以得出类似于辗转相除法的结论：`f(x,y) = f(x-y,y)`。这个递推公式没有求余运算，可以节省开销。

- 算法示例：f(42,30) = f(30,12) = f(12,18) = f(18,12) = f(12,6) = f(6,6) = f(6,0) = 6.

- 算法代码如下：

		int gcd(int x, int y){
			//若x小于y，则互换x和y（f(x,y)满足交换律），确保调用过程中不会出现负数
			if(x < y){
				return gcd(y, x);
			}
			//若y等于0，则x就是最大公约数
			if(y == 0)
				return x;
			//若y不等于0，则继续递归调用gcd(x-y, y)
			else
				return gcd(x-y, y);
		}

- 算法缺点：相比于除法，减法的迭代次数太多。

####解法三——“类”辗转相除法的进一步优化####

- 继续深入分析，可以得出以下结论：

	1. 若x、y均为偶数，则`f(x, y) = 2 * f(x/2, y/2)`
	
	2. 若x为偶数，y为奇数，则`f(x, y) = f(x/2, y)`
	
	3. 若x为奇数，y为偶数，则`f(x, y) = f(x, y/2)`

	4. 若x、y均为奇数，则`f(x, y) = f(x-y, y)`

- 算法示例及代码略。

- 算法优点：该算法避免了大整数求余运算，也避免了只用减法导致迭代次数过多的问题。另外“除以2”可以用“右移一位”来加速。

##2.8 找符合条件的整数##

###问题描述###

任意给定一个正整数N，求一个最小的正整数M，使得N*M的十进制表示形式里只含有1和0。

###解决思路###

- 原问题等价于“求一个最小的正整数X，使得X的十进制表示形式中只包含1和0，且X要被N整除”。

- 对于新问题的求解，可以列出所有X可能的取值（十进制形式中只包含1和0）：1、10、11、100、101、110、111-1000、1001、1010、1011、1100、1101、1110、1111、10000……，然后逐个验证是否可以整除N。

- 以上解法需要逐个验证所有可能的X值，但是其中有一些X值的验证是不必要的（可以从已验证的X值推断出来未验证的某些X值对N的求余是一样的），具体的分析略。

##2.9 斐波那契数列##

###问题描述###

求解斐波那契数列第N项的值。

###解决思路###

####解法一——经典递归写法####

	int Fibonacci(int n){
		if(n <= 0){
			return 0;
		} else if(n == 1){
			return 1;
		} else {
			//递归写法直接使用了斐波那契数列的定义式
			return Fibonacci(n-1) + Fibonacci(n-2);
		}
	}

####解法二——经典非递归写法####

	int Fibonacci(int n){
		int sum = 0;
		int sum1 = 1;
		int sum2 = 1;
		
		if(n==1 || n==2)
			return 1;
		else {
			///循环中通过sum、sum1、sum2这三个变量来存储已计算过的值，避免重复计算
			for(int i=2; i < n; i++){
				//sum是第n项，sum1是第n-1项，sum2是第n-2项
				sum = sum1 + sum2;
				//sum2从第n-2项变为第n-1项（右移一项）
				sum2 = sum1;
				//sum1从第n-1项变为第n项（右移一项）
				sum1 = sum;
				//sum2和sum1的右移是为下一次循环（计算第n+1项）做准备
			}
			返回第n项
			return sum;
		}
	}

##2.10 寻找数组中的最大值和最小值##

###问题描述###

同时找到一个数组中的最大值和最小值。

###解决思路###

####解法一####

顺序扫描两遍数组，分别找出最大值和最小值。

####解法二####

采用**分治**策略，将原来长度为N的数组分为前后两个长度为N/2的子数组，分别求出两个子数组的最大值和最小值，较小的最小值和较大的最大值就是原数组的最小值和最大值。

算法代码如下：

	(max, min) Search(arr, b, e){
	
		//递归退出的边界条件
		if(e-b <= 1){
			if(arr[b] < arr[e])
				return (arr[e], arr[b]);
			else 
				return (arr[b], arr[e]);
		}

		//递归地去找左半部分的最大值和最小值
		(maxL, minL) = Search(arr, b, b+(e-b)/2);
		//递归地去找右半部分的最大值和最小值
		(maxR, minR) = Search(arr, b+(e-b)/2+1, e);

		//比较左半部分和右半部分的最大值，较大者为整个数组的最大值
		if(maxL > maxR)
			maxV = maxL;
		else 
			maxV = maxR;
		
		//比较左半部分和右半部分的最小值，较小者为整个数组的最小值
		if(minL < minR)
			minV = minL;
		else 
			minV = minR;
		
		//返回整个数组的最大值和最小值
		return (maxV, minV);
	}

##2.11 寻找最近点对##

###问题描述###

给定平面上N个点的坐标，找出距离最近的两个点。如下图所示。

![](http://i.imgur.com/ErDE7yc.png)

###解决思路###

- 直接的解法是计算各个点两两之间的距离，最后求距离最小值即可。

- 更高效的解法是采用**分治策略**，把点分为左右两部分，分别计算左右两部分中距离最短的两点，那么整个点集中距离最短的两点可能有三种情况：

	- 都在左半部分，也即是左半部分距离最短的两点。

	- 都在右半部分，也即是右半部分距离最短的两点。

	- 一个点在左半部分，另一个点在右半部分。

- 前两种情况可以递归求出，关键在于第三种情况的求解：假设左右两部分由直线x=M划分，并且左半部分和右半部分的最近点对距离分别为`MinDist(Left)`和`MinDist(Right)`，那么令`MDist=MinValue(MinDist(Left), MinDist(Right))`，我们只需考虑从x=M-MDist到x=M+MDist之间这个带状区域内的最近点对即可。也就是说，如果是第三种情况，那么这两个点一定在这个带状区域之内。将这个带状区域内的最小点对距离与MDist进行比较，较小者就是整个点集中的最近点对距离。

![](http://i.imgur.com/4aZRcNH.png)

###扩展问题###

####问题描述####

如果给定一个数组arr[0,1,……,N-1]，要求找出**相邻**两个数的最大差值。**相邻**的定义：对于数X和Y，如果不存在其他数组中的数在[X,Y]区间内，则X和Y是相邻的。

####解决思路####

- 设数组中一共有N个数，其中最大的数为max,最小的数为min，那么根据**抽屉原理**，相邻两个数的最大差值一定不小于delta=(max-min)/(N-1)（反证法可证明）。

- 把区间分成N个**桶**：[min,min+delta]，[min+delta,min+delta*2]，……，[max-delta,max]。那么根据上述结论，最大的差值应该出现在不同的桶之间（因为不可能出现在同一个桶中，那样的话，最大差值就小于delta了，与上述结论矛盾）。进一步可以知道，最大差值应该是某一个桶的最小值减去前一个非空桶的最大值。因此扫描一遍所有的桶，就可以得出结果了。

##2.12 快速寻找满足条件的两个数##

###问题描述###

找出一个数组中的两个数，让这两个数之和等于一个给定的值。例如对于数组5,6,1,4,7,9,8，给定值SUM=10，那么数组中的(6,4)、(1,9)符合要求。

###解决思路###

####解法一####

- 原问题可以转换为如下问题：对于数组中的每一个数arr[i]，都判别SUM-arr[i]是否在数组中。

- 最原始的查找需要花费O(N^2)时间（对于每一个数都要扫描一趟数组，花费O(N)时间；而一共有N个数，需要扫描N趟）。

- 可以先将原始数组排序（花费O(N * logN)时间），然后采用二分查找。这样对于每一个数，查找的时间为O(logN)；总共N个数需要花费O(N * logN)时间。

- 更进一步的优化：可以采用hash表来存储数组中的数。由于hash散列查找一个数只需花费O(1)时间，因此N个数的查找共需要花费O(N)时间。但是该算法需要额外O(N)的hash存储空间，因此这属于**空间换时间**的算法。

####解法二####

- 换个角度考虑这个问题：首先对数组从小到大进行排序，然后在数组首尾设置两个游标（i=0，j=N-1），考察arr[i]+arr[j]和SUM的关系：

	+ 若arr[i]+arr[j] = SUM，则说明找到了符合要求的两个数，算法结束；
	
	+ 若arr[i]+arr[j] > SUM，则 j 左移（j--）；
	
	+ 若arr[i]+arr[j] < SUM，则 i 右移（i++）；

- 以上算法可以形象地描述为“设立首尾两个游标，然后向中间挤”。该算法只需要排序的O(N * logN)时间、加上扫描一遍数组的O(N)时间即可。

##2.13 子数组的最大乘积##

###问题描述###

给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意(N-1)个数的组合中乘积最大的一组。

###解决思路###

####解法一####

- (N-1)个数的组合的乘积，也即除去某一个数之外的剩余所有数的乘积。

- 可以额外维护三个数组：前i个元素的乘积S[i]，后N-i个元素的乘积T[i]，除去第i个元素外剩余(N-1)个元素的乘积P[i]。显然`P[i] = S[i-1] × T[i+1]`。其中，S[i]满足`S[i] = S[i-1] × arr[i-1]`，扫描一遍数组即可求出；T[i]满足`T[i]=T[i+1] × arr[i]`，也是扫描一遍数组即可求出；同理，P[i]也可以线性时间内求出。数组P的最大值即为最终结果。

####解法二####

- 假设数组中N个数的乘积为P，那么考虑P的正负性：

	+ 若P为0，则说明数组中至少包含一个0。假设除去一个0之外，其余N-1个数的乘积为Q，则考虑Q的正负性：
	
		+ Q为0，说明数组中至少有两个0，那么任意N-1个数的乘积必然为0，也即任意N-1个数的乘积最大值为0；
		
		+ Q为正数，说明数组中有且仅有一个0，那么任意N-1个数的乘积最大值为Q；

		+ Q为负数，说明数组中有且仅有一个0，那么任意N-1个数的乘积最大值为0；

	+ 若P为负数，说明数组中有负数存在，那么根据“负负得正”，我们把数组中绝对值最小的负数去掉，剩余元素的乘积就是绝对值最大的正数了，即最终结果。

	+ 若P为正数，那么考虑两种情况：
		
		+ 数组中没有正数，全部是负数（当然是偶数个），那么去掉绝对值最大的负数，剩余的N-1个数的乘积就是绝对值最小的负数了，即最终结果；

		+ 数组中有正数，那么去掉绝对值最小的正数，剩余的N-1个数的乘积就是绝对值最大的正数了，即最终结果。

- 这种解法可以更进一步提高效率：不必计算乘积，只需求出数组中正数、负数、0的个数，然后分情况讨论，求得结果。

##2.14 求数组的子数组之和的最大值##

###问题描述###

给定一个有N个整数元素的数组，这个数组当然有很多子数组，那么如何求子数组之和的最大值？

###解决思路###

####解法一####

最直接的方法，计算每一个子数组arr[i],……,arr[j]的和，其中最大者就是子数组之和的最大值。该算法时间复杂度为O(N^2)。

####解法二####

- 采用**分治策略**，把原数组分为左右两部分，那么子数组之和的最大值有以下三种可能：

	+ 原数组的子数组之和最大值等于左半部分的子数组之和最大值，如下图中的ma；

	+ 原数组的子数组之和最大值等于右半部分的子数组之和最大值，如下图中的mb；

	+ 原数组的子数组之和最大值跨过左、右两部分，如下图中的mc。

![](http://i.imgur.com/SGc6X45.png)

![](http://i.imgur.com/q4FDtcl.png)

- 前两种情况可以递归求出，关键在于第三种情况的求解：由于所求子数组跨过左右两部分，因此它必然包含以arr[N/2 - 1]结尾的、和最大的一段数组，也必然包含以arr[N/2]开头的、和最大的一段数组。这两段数组拼接起来就是原数组中和最大的子数组，即为所求。

- 该算法的代码如下：

		int maxsum(int start, int end){
			//数组中没有元素
			if(start > end) 
				return 0;
			//数组中有一个元素
			if(start == end)
				return max(0, arr[start]);
			//求出原数组的中点，将其划为左右两部分
			int mid = (start + end) / 2;
	
			int leftmax = sum = 0;
			//计算出左半部分以arr[N/2 - 1]结尾的、和最大的一段子数组
			for(int i = mid; i >= 1; i--){
				sum += arr[i];
				leftmax = max(leftmax, sum);
			}
			
			int rightmax = sum =0;
			//计算出右半部分以arr[N/2]开头的、和最大的一段子数组
			for(int i = mid; i <= end; i++){
				sum += arr[i];
				rightmax = max(rightmax, sum);
			}
			/*求出横跨左右两部分的最大和leftmax + rightmax、左半部分的最大和（递归求出）、
				右半部分的最大和（递归求出），三者中的较大者就是原数组中的最大和*/
			return max(leftmax + rightmax, maxsum(start, mid), maxsum(mid+1, end));
		}

- 该算法由于采取了分治策略，每次都将问题规模减半，因此时间复杂度为O(N * logN)。

####解法三####

- 通过思考可以得出如下结论：在数组的前i个元素中，最大总和子数组要么在前i-1个元素中（记为maxsofar），要么截止于当前位置i（记为maxendinghere），如下图所示。

![](http://i.imgur.com/7NybT2f.png)

- 通过比较maxsofar和maxendinghere可以求出最大和，代码如下：

		int maxsofar = 0;
		int maxendinghere = 0;
		
		for(int i = 0; i < n; i++){
			//计算新的maxendinghere值（若为负值，则将其重新设为0，因为截止于i的最大总和子数组现在为空了）
			maxendinghere = max(maxendinghere + arr[i], 0);
			//计算新的maxsofar值（取原来maxsofar值和maxendinghere值的较大者），作为本次迭代之后的最大和
			maxsofar = max(maxsofar, maxendinghere);
		}

- 该算法的代码相当微妙，但是效率很高，只需要线性扫描一遍数组即可，时间复杂度为O(1)。

###扩展问题###

####问题描述####

假如数组是首尾相连的呢？也即最大总和子数组可以从数组末尾绕到开头。

####解决思路####

- 这个问题的解有两种可能：一是最大总和子数组没有首尾相连（原问题），二是最大总和子数组跨过了首尾。

- 对于第二种可能，还需分为两种情况：

	+ 跨过首尾的子数组就是整个数组。

	+ 跨过首尾的子数组不是整个数组，因此它包含两个部分：从arr[0]到arr[i]的一段和从arr[j]到arr[N-1]的一段。其中i<j。这种情况相当于从原数组中删除了从arr[i+1]到arr[j-1]的一段，取剩余部分的最大总和。那么只需要满足从arr[i+1]到arr[j-1]的和为负数且绝对值最大即可（由于数组总和固定，故而被删除的这段之和与剩余部分之和此消彼长）。于是问题就转化为“求子数组之和的最小值且为负”。这个问题的求解与原问题类似。

- 最终，取两种可能解的较大者即可。

##2.15 子数组之和的最大值（二维）##

###问题描述###

将上一个问题“求解一维数组的子数组最大总和”扩展到二维情形，如图所示。



###解决思路###

- 最直接的方法是枚举每一个矩形区域，求这个区域内的元素和。该算法时间复杂度太大，并且没有利用到已有的计算结果。

- 可以预先计算好会频繁用到的结果，避免重复计算。这些预处理的数据需要额外的存储空间，因此属于**空间换时间**算法。

- 具体的实施，可以预先计算好二维数组的**部分和**。定义“部分和”PS[i][j]等于以(1,1)、(i,1)、(1,j)、(i,j)为顶点的矩形区域的元素之和，也即(i,j)左上方的元素之和。那么对于任意一个矩形区域(imin,jmin)、(imin,jmax)、(imax,jmin)、(imax,jmax)，其中的元素和等于`PS[imax][jmax] - PS[imin][jmax] - PS[imax][jmin] + PS[imin][jmin]`，如下图所示。由于已经预先计算好了“部分和”，因此计算任意矩形区域内的元素和只需O(1)时间。

![](http://i.imgur.com/0r56zG6.png)

- “部分和”的计算也可以通过存储先前计算结果逐个得到：`PS[i][j] = PS[i-1][j] + PS[i][j-1] - PS[i-1][j-1] + arr[i][j]`，如下图所示。

![](http://i.imgur.com/ndfSHN5.png)

- 以上算法的基本思想就是预先计算好并存储可能会频繁用到的数据，避免重复计算，从而节省时间。

##2.16 求数组中最长递增子序列##

###问题描述###

求一个一维数组（包含N个元素）中最长递增子序列的长度。例如在序列1，-1,2，-3,4，-5,6，-7中，最长递增子序列的长度为4（如子序列1,2,4,6）。

###解决思路###

- 我们在找递增子序列的时候，当我们找到某个值以后（例如上例中找到4以后），我们并不关心4之前的其他值是怎么样的，它们对我们接下来找到6没有任何影响。因此该问题满足**无后效性**，可以用**动态规划**来解决。（注：无后效性指的是对于某个给定阶段的状态，它之前各阶段的状态不会影响到它未来的决策）

- 使用动态规划算法要描述各阶段状态之间的转移规律。通过观察我们发现：当迭代到第i个元素时，如果arr[i+1] > arr[k]（其中k<i），那么第i+1个元素arr[i+1]可以接在LIS[k]长的递增子序列后面构成一个更长的递增子序列，其中LIS[k]为前k个元素中的最长递增子序列长度。

- 根据以上规律写出代码如下：

		int LIS(int[] arr){
			//创建LIS数组，LIS[i]表示前i个元素的最长递增子序列长度
			int[] LIS = new int[arr.length];
			for(int i=0; i<arr.length; i++){
				//初始化LIS[i]为1，因为第i个元素arr[i]本身至少可以构成一个长度为1的最长递增子序列
				LIS[i] = 1;
				for(int k=0; k<i; k++){
					/*对于第i个元素arr[i]之前的每一个元素arr[k]，如果arr[i]大于它，那么就可
						以把arr[i]接到它后面，构成一个更长的递增子序列。这样前i个元素的最长递
						增子序列长度就更新为LIS[k]+1了，若该值大于原来前i个元素的最长递增子序
						列长度LIS[i]，则更新LIS[i]，表明它就是当前最新得到的前i个元素的最长
						递增子序列长度。*/
					if(arr[i] > arr[k] && LIS[k] + 1 > LIS[i]){
						LIS[i] = LIS[k] + 1;
					}
				}
			}
			//最后返回LIS中最大的值，就是整个数组中最长递增子序列的长度
			return max(LIS);
		}

- 该算法比较巧妙，需要仔细理解。此外，该算法时间复杂度为O(N^2)。

##2.17 数组循环移位##

###问题描述###

把一个含有N个元素的数组循环右移K位，如何尽可能高效地实现？

###解决思路###

- 最直接的方法是，每次将数组中的所有元素右移一位，循环K次，这样算法时间复杂度为O(N * K)。

- 以上这种方法，当K>N时，算法时间复杂度会超过O(N^2)。而容易看出来右移K位和右移K%N位的效果是一样的。因此当K>N时，只需要进行K%N次“右移一位”操作即可，这样算法时间复杂度不会超过O(N^2)。

- 除此之外，还有一种巧妙的方法——**三次翻转法**。以序列1234abc为例，要求将该序列循环右移3位，变为abc1234，我们可以采取如下步骤：
 
	+ 先将左边4位（1234）翻转，得到4321abc；

	+ 再将右边3位（abc）翻转，得到4321cba；

	+ 最后将整个序列翻转，得到abc1234，即为最终结果。

- 三次翻转算法的代码如下：

		//将数组从起始下标beginner到结束下标end之间的部分翻转
		void Reverse(int[] arr, int beginner, int end){
			for(; beginner < end; beginner++, end--){
				int tmp = arr[beginner];
				arr[beginner] = arr[end];
				arr[end] = tmp;
			}
		}
		
		//通过三次翻转操作实现数组的循环右移
		void RightShift(int[] arr, int N, int K){
			K %= N;
			//第一次翻转，将数组左半部分（从0到N-K-1）翻转
			Reverse(arr, 0, N-K-1);
			//第二次翻转，将数组右半部分（从N-K到N-1）翻转
			Reverse(arr, N-K, N-1);
			//第三次翻转，将数组整体全部翻转，得到最终结果
			Reverse(arr, 0, N-1);
		}

- 三次翻转法的时间复杂度为O(N)。

##2.18 数组分割##

###问题描述###

待补充

###解决思路###

待补充

##2.19 区间重合判断##

###问题描述###

给定一个源区间[x,y]和N个无序的目标区间[x1,y1]、[x2,y2]、……、[xn,yn]，判断源区间[x,y]是否在目标区间内？

例如，给定源区间[1,6]和一组无序的目标区间[2,3]、[1,2]、[3,9]，即可认为源区间[1,6]在目标区间[2,3]、[1,2]、[3,9]内（因为目标区间合并后实际上是[1,9]）。

###解决思路###

- 先对若干个无序的目标区间按起始坐标从小到大进行排序，例如[2,3]、[1,2]、[3,9] -> [1,2]、[2,3]、[3,9]；然后将这些区间合并为若干个互不相交的区间，例如[1,2]、[2,3]、[3,9] -> [1,9]。

- 完成目标区间的排序与合并之后，再检查源区间是否被合并之后的互不相交的目标区间中的某一个所包含。这里可以线性地逐个检查每个目标区间，也可以采用二分查找来检查。

- 以上算法体现了一种很普遍的思路：在解决问题之前，先对输入数据进行诸如排序、合并等预处理，从而简化后续的处理难度。

##2.20 程序理解和时间分析##

###问题描述###

理解并分析下列程序的含义。

	using System;  
	using System.Collections.Generic;  
	using System.Text;  
	   
	namespace FindTheNumber
	{
	     class Program
	     {
	          static void Main(string[] args)
	          {
	               int [] rg =
	               {2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,
	               18,19,20,21,22,23,24,25,26,27,28,29,30,31};
	   
	               for(Int64 i = 1; i < Int64.MaxValue; i++)
	               {
	                    int hit = 0;
	                    int hit1 = -1;
	                    int hit2 = -1;
	                    for (int j = 0; (j < rg.Length) && (hit <= 2); j++)
	                    {
	                          if((i % rg[j]) != 0)
	                          {
								   //hit表示i不能被rg[j]整除的个数。例如hit=5，表示i不能被数组rg中的某5个数整除
	                               hit++;
	                               if(hit == 1)
	                               {
										//hit1表示i第一次不能被rg[j]整除时的下标
	                                    hit1 = j;
	                               }
	                               else if (hit == 2)
	                               {
										//hit2表示i第二次不能被rg[j]整除时的下标
	                                    hit2 = j;
	                               }
								   //若hit大于2，说明i至少不能被数组rg中的某三个数整除，循环退出
	                               else
	                                    break;
	                          }
	                    }
	   					/*若hit等于2，说明i不能被数组rg中的某两个数整除，但可以被rg中其余的
						任何数整除；并且hit1+1等于hit2，也即i第一次和第二次不能被整除的数的
						下标相差1（两者相邻）。因此i应当满足以下条件：不能被数组rg中某两个相
						邻的数整除，但能被rg中其余的任何数整除。*/
	                    if((hit == 2) && (hit1 + 1 == hit2))
	                    {
	                          Console.WriteLine("found {0}", i);
	                    }
	               }
	          }
	     }
	}

###解决思路###

- 这段程序的详细分析见注释，要找的数应满足“不能被2~31这30个数中的某两个相邻的数整除，但可以被其余28个数整除”。

- 由于该数可以被其中的28个数整除，因此它是这28个数的最小公倍数的整数倍；而该数又不能被两个相邻的数整除，因此该数分解质因数后的因子应该不被这两个相邻的数所包含，或者幂次小于这两个数中相同因子的幂次，所以这两个数很可能是**质数**或**完全平方数**。故最终找到的这两个相邻的数是16和17，该数=2^3 × 3^3 × 5^2 × 7 × 11 × 13 × 19 × 23 × 29 × 31 ≈ 2.1 × 10^12。

- 由于该数约等于2.1 × 10^12，因此需要进行这么多次for循环，由此可以估算出该程序的运行时间。


##2.21 只考加法的面试题##

###问题描述###

对于一个64位正整数，写出它所有可能的连续自然数之和的算式。例如给定正整数9，它可以写作4+5，也可以写作2+3+4。

###解决思路###

- 设给定的正整数为X，它可以写作连续i+1个自然数之和，那么有`X = a + (a+1) + (a+2) + …… + (a+i) = a×(i+1) + i×(i+1)/2`。我们可以确定i的取值范围，在这个范围内逐个尝试i值，然后根据上式求出相应的a值，若a值为整数，那么就得到一个连续自然数之和的算式。

- i的范围可以这样求解：当i最大的情况下，满足`X = 1 + 2 + 3 + …… + (imax+1)`，因此`imax = ((8X+1)^0.5-1)/2 - 1`，从而i的取值范围是`1 <= i <= ((8X+1)^0.5-1)/2 - 1`。

- 求得i的取值范围之后，在此范围内遍历i值即可。