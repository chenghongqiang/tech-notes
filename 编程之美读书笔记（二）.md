# 《编程之美》读书笔记（二） #

数字之魅——数字中的技巧

##2.1 求二进制数中1的个数##

###问题描述###

对于一个字节（8bit）的无符号整型变量，求其二进制表示中“1”的个数，要求算法执行效率尽可能的高。

###解决思路###

####解法一####

对于二进制数来说，可以将其**除以2并求余数**来判断末位是0还是1。以10100101为例，第一次除以2时余数为1，说明该位为1；继续除以2，余数为0，说明该位为0。代码如下：

	int Count(BYTE v){
		int num = 0;
		while(v){
			//除以2，判断余数，余数为1则说明末位为1
			if(v % 2 == 1){
				num++;
			}
			//保存商，为下一次循环做准备
			v = v/2;
		}
		return num;
	}

####解法二####

上述解法中的**除以2**操作，在二进制数中可以用**右移一位**来代替。例如对于10100001来说，首先将其与00000001**相与**，结果为1，说明当前末位为1；然后右移一位，继续与00000001相与……。这种解法使用**右移**+**与操作**替代了解法一的**除以2**+**求余**操作。

####解法三####

由于问题仅涵盖8位的整数（0——255之间），因此可以预先将这256个数中“1”的个数存储起来，例如存储到一个长度为256的数组中，在求解时无需计算，直接返回答案。

这种算法是典型的**空间换时间**的思想。

##2.2 不要被阶乘吓倒##

###问题描述###

1. 给定一个整数，求解N的阶乘N!的末尾有多少个0？例如：N=10，N!=3628800，末尾有2个0。

2. 求N!的二进制表示中最低位1的位置。

###解决思路###

####问题1####

- 求解阶乘N!的末尾有多少个0，可以转化为以下问题：对于N!=K×10^M，且K不能被10整除，求解M的值。

- 更进一步，可以对N!进行质因数分解N!=(2^X)×(3^Y)×(5^Z)×……，由于2×5=10，所以M只与X和Z相关，每一对2和5相乘可以得到一个10，于是M=min(X,Z)。

- 再进一步，由于能被2整除的数要比能被5整除的数要多，所以M=Z。因此只要求出Z的值，也就是N!的质因数分解中5的个数，就能得到N!中末尾0的个数。

- 根据以上思路，写出代码如下：

		ret = 0;
		for(i = 1; i <= N; i++){
			j = i;
			//循环每进行一次，说明找到一个质因数5，ret值增1
			while(j % 5 == 0){
				ret++;
				j /= 5;
			} 
		}

####问题2####

- 求解N!的二进制表示中最低位1的位置，可以转化为求解N!含有质因数2的个数。（因为假如最低位1在第M位，那么说明更低的M-1位都是0，因此说明该数包含M-1个质因数2）

- 求解质因数2的个数可以采用问题1的解法。另外注意：“除以2”操作可以用“右移一位”操作来代替。

##2.3 寻找发帖“水王”##

###问题描述###

如果一个列表中，某个值的出现次数超过了列表总长度的一半，那么如何快速找到这个值？

###解决思路###

- 比较简单的方法：可以先将列表排序，由于这个值出现了超过一半的次数，那么这个列表**正中间**的一项一定是这个值，直接返回该值即可。这种算法需要先排序（花费至少O(N*logN)时间），然后再用O(1)时间返回结果。

- 效率更高的方法：每次删除两个**不相同**的值（不管是否包含要找的这个值），那么，在列表中剩下的值中，要找的这个值出现的次数仍然会超过一半。可以不断重复这个过程，把列表中的元素总数降低（转化为更小的问题）。这样对列表只需进行一趟遍历就能找到这个值，所需时间为O(N)。

- 第二种解法里，把原问题转化为规模较小的子问题的思想在计算机科学中非常普遍，分治算法、动态规划算法、递归算法、贪心算法等等都基于这种思想。

##2.4 1的数目##

###问题描述###

给定一个十进制正整数N，写下从1开始到N的所有整数，然后求出其中出现“1”的次数。例如N=12，写下1,2,3,4,5,6,7,8,9,10,11,12，其中“1”的次数为5。

###解决思路###

- 可以从简单的情形开始分析观察，总结其中的**数学规律**，加以推广的一般情形。

- 对于此题来说，可以先考察1位数的情况、再考察2位数的情况、接着考察3位数的情况……最终推广到一般情形。

##2.5 寻找最大的K个数##

###问题描述###

假设有N个无序的数，如何找出其中最大的K个数呢？

###解决思路###

####解法一——部分冒泡排序####

由于冒泡排序每趟会把最大的元素“沉底”，因此可以执行K趟冒泡，把前K个大的数“沉底”，从而找到最大的K个数。这种方法不必执行完整的冒泡排序，时间复杂度为O(N*K)。

####解法二——快速选择####

- 快速选择的思想取自快速排序算法，将集合分为枢纽元、左半部分（其中元素均大于枢纽元）和右半部分（其中元素均小于枢纽元），从而递归完成排序。

- 用快速选择法找出最大的K个数的算法如下：

	+ 假设K个数存储在数组S中，我们从数组S中随机找出一个元素X（枢纽元），把数组分成两部分Sa和Sb，其中Sa中的元素大于等于X，Sb中的元素小于X。此时有两种可能性：

		1. Sa中的元素个数小于K，那么最大的K个数 = Sa中的全部元素 + Sb中最大的K-|Sa|个元素。
		
		2. Sa中的元素个数大于等于K，那么最大的K个数 = Sa中最大的K个数。
	
	+ 无论是以上哪种情形，接下来都需要递归地在Sa或Sb中找到最大的若干个数，最终通过递归实现求解。

- 快速选择法的伪代码如下：

		//函数Kbig用于找到集合S中最大的k个数
		Kbig(S, k):
			if(k <= 0)
				return [];
			if(S.length <= k)
				return S;
			//首先调用函数Partition()，将S分为Sa和Sb两部分，其中Sa中的元素均大于Sb中的元素
			(Sa, Sb) = Partition(S);
			/*然后有两种情况：
				1、Sa的大小小于k，则返回Sa中全部元素，加上Sb中的前k-|Sa|个元素
				2、Sa的大小大于等于k，则返回Sa中的前k个元素
			  以下代码将上述两种情况统一为了同一种递归写法*/
			return Kbig(Sa, k).append(Kbig(Sb, k-Sa.length));

		//函数Partition用于将集合S分成Sa、Sb两部分，其中Sa中的元素均大于Sb中的元素
		Partition(S):
			Sa=[]; Sb=[];
			//随机选取枢纽元p
			p = S[random];
			//对于集合S中除了p之外的其他元素，若大于p则放入Sa中，否则放入Sb中
			for i in S except p:
				S[i] > p ? Sa.append(S[i]) : Sb.append(S[i])
			//最后将枢纽元本身也放入Sa或Sb中
			Sa.length < Sb.length ? Sa.append(p) : Sb.append(p);
			//返回分好的两个子集Sa、Sb
			return (Sa, Sb); 

- 快速选择法的平均时间复杂度为O(N*logK)。

####解法三——使用最小堆####

- 使用一个容量为K的**最小堆**，首先把集合前K个数依次放入堆中并保持堆序，此时集合中还剩下N-K个数。

- 逐个把剩下的N-K个数放入堆中，对于每个新到来的数，分两种情况讨论：

	+ 若这个数小于堆顶元素，说明这个数比堆中所有的K个数都小，那么它肯定不属于最大的K个数之列，所以摒弃这个数。

	+ 若这个数大于堆顶元素，那么这个数有可能属于最大的K个数之列。用它来替换堆顶元素（将原来的堆顶元素摒弃），这时堆序性质可能会被破坏，需要通过“下滤”操作来调整并保持堆序性质。

- 当把剩下的N-K个数逐个扫描之后，算法结束，此时堆中的K个数就是集合中最大的K个数。

- 上述算法中，每次新元素的“下滤”操作平均花费时间为O(logK)，因此算法总时间为O(N*logK)（包括建堆的时间）。

####解法四——桶式排序####

若集合中的数都是位于[0, MAXN]之间的正整数，则可以采用桶式排序，排序之后返回前K个元素即可。

##2.6 精确表达浮点数##

###问题描述###

待补充

###解决思路###

待补充

##2.7 最大公约数问题##

###问题描述###

求解两个正整数的最大公约数（Greatest Common Divisor，GCD）

###解决思路###

####解法一——辗转相除法####

- 假设用f(x,y)来表示x和y的最大公约数（其中x>=y），那么取k=x/y，b=x%y，则x=ky+b。如果一个数能够同时整除x和y，那么它一定可以同时整除b和y；另一方面，如果一个数能够同时被b和y整除，那么它一定可以同时被x和y整除。也就是说，x和y的公约数与b和y的公约数是相同的，其最大公约数也是相同的，也即满足`f(x,y) = f(x%y,y)`。这样便可以把原问题转化为求两个更小的数的最大公约数，直到其中一个数为0，则另一个数就是两者的最大公约数。

- 辗转相除法的示例：f(42,30) = f(30,12) = f(12,6) = f(6,0) = 6.

- 辗转相除法的代码：

		int gcd(int x, int y){
			//若y等于0，则x就是最大公约数；若y不等于0，则继续递归调用gcd(y, x%y)
			return (!y) ? x : gcd(y, x%y);
		}

- 算法缺点：如果遇到大整数，则求余操作开销较大。

####解法二——“类”辗转相除法####

- 借鉴解法一的分析，可以得出类似于辗转相除法的结论：`f(x,y) = f(x-y,y)`。这个递推公式没有求余运算，可以节省开销。

- 算法示例：f(42,30) = f(30,12) = f(12,18) = f(18,12) = f(12,6) = f(6,6) = f(6,0) = 6.

- 算法代码如下：

		int gcd(int x, int y){
			//若x小于y，则互换x和y（f(x,y)满足交换律），确保调用过程中不会出现负数
			if(x < y){
				return gcd(y, x);
			}
			//若y等于0，则x就是最大公约数
			if(y == 0)
				return x;
			//若y不等于0，则继续递归调用gcd(x-y, y)
			else
				return gcd(x-y, y);
		}

- 算法缺点：相比于除法，减法的迭代次数太多。

####解法三——“类”辗转相除法的进一步优化####

- 继续深入分析，可以得出以下结论：

	1. 若x、y均为偶数，则`f(x, y) = 2 * f(x/2, y/2)`
	
	2. 若x为偶数，y为奇数，则`f(x, y) = f(x/2, y)`
	
	3. 若x为奇数，y为偶数，则`f(x, y) = f(x, y/2)`

	4. 若x、y均为奇数，则`f(x, y) = f(x-y, y)`

- 算法示例及代码略。

- 算法优点：该算法避免了大整数求余运算，也避免了减法迭代次数过多的缺点。另外“除以2”可以用“右移一位”来加速。

##2.8 找符合条件的整数##

###问题描述###

任意给定一个正整数N，求一个最小的正整数M，使得N*M的十进制表示形式里只含有1和0。

###解决思路###

- 原问题等价于“求一个最小的正整数X，使得X的十进制表示形式中只包含1和0，且X要被N整除”。

- 对于新问题的求解，可以列出所有X可能的取值（十进制形式中只包含1和0）：1、10、11、100、101、110、111-1000、1001、1010、1011、1100、1101、1110、1111、10000……，然后逐个验证是否可以整除N。

- 以上解法需要逐个验证所有可能的X值，但是其中有一些X值的验证是不必要的（可以从已验证的X值推断出来未验证的某些X值对N的求余是一样的），具体的分析略。

##2.9 斐波那契数列##

###问题描述###

求解斐波那契数列第N项的值。

###解决思路###

####解法一——经典递归写法####

	int Fibonacci(int n){
		if(n <= 0){
			return 0;
		} else if(n == 1){
			return 1;
		} else {
			//递归写法直接使用了斐波那契数列的定义式
			return Fibonacci(n-1) + Fibonacci(n-2);
		}
	}

####解法二——经典非递归写法####

	int Fibonacci(int n){
		int sum = 0;
		int sum1 = 1;
		int sum2 = 1;
		
		if(n==1 || n==2)
			return 1;
		else {
			///循环中通过sum、sum1、sum2这三个变量来存储已计算过的值，避免重复计算
			for(int i=2; i < n; i++){
				//sum是第n项，sum1是第n-1项，sum2是第n-2项
				sum = sum1 + sum2;
				//sum2从第n-2项变为第n-1项（右移一项）
				sum2 = sum1;
				//sum1从第n-1项变为第n项（右移一项）
				sum1 = sum;
				//sum2和sum1的右移是为下一次循环（计算第n+1项）做准备
			}
			返回第n项
			return sum;
		}
	}

##2.10 寻找数组中的最大值和最小值##

###问题描述###

同时找到一个数组中的最大值和最小值。

###解决思路###

####解法一####

顺序扫描两遍数组，分别找出最大值和最小值。

####解法二####

采用**分治**策略，将原来长度为N的数组分为前后两个长度为N/2的子数组，分别求出两个子数组的最大值和最小值，较小的最小值和较大的最大值就是原数组的最小值和最大值。

算法代码如下：

	(max, min) Search(arr, b, e){
	
		//递归退出的边界条件
		if(e-b <= 1){
			if(arr[b] < arr[e])
				return (arr[e], arr[b]);
			else 
				return (arr[b], arr[e]);
		}

		//递归地去找左半部分的最大值和最小值
		(maxL, minL) = Search(arr, b, b+(e-b)/2);
		//递归地去找右半部分的最大值和最小值
		(maxR, minR) = Search(arr, b+(e-b)/2+1, e);

		//比较左半部分和右半部分的最大值，较大者为整个数组的最大值
		if(maxL > maxR)
			maxV = maxL;
		else 
			maxV = maxR;
		
		//比较左半部分和右半部分的最小值，较小者为整个数组的最小值
		if(minL < minR)
			minV = minL;
		else 
			minV = minR;
		
		//返回整个数组的最大值和最小值
		return (maxV, minV);
	}