# 《编程之美》读书笔记（一） #

游戏之乐——游戏中碰到的题目

##1.1 让CPU占用率曲线听你指挥##

###问题描述###

- 使CPU占用曲线保持恒定（例如30%），呈一条直线。

- 令CPU占用曲线呈正弦曲线。

###解决思路###

- 一个程序在运行时，使得CPU闲下来（使用率为0%）的条件是该程序在等待用户输入、或等待某些事件的发生、或主动进入休眠状态（调用`Sleep()`函数）。

- 任务管理器的CPU占用曲线显示的是**每个刷新周期内**CPU占用率的**统计平均值**。

- 因此可以写一个程序，使它在任务管理器的一个刷新周期内一会儿忙，一会儿闲，然后调节忙/闲比例，就可以控制CPU占用曲线为一条特定的直线。

- 需要注意的是，应当在允许的范围内尽量减少sleep/awake（睡眠/唤醒）频率，以减少操作系统内核调度程序的频繁调度对CPU使用率的干扰；并且尽量不要调用系统函数，因为它也会导致不可控的内核运行时间，从而影响CPU使用率。

- 要使CPU占用曲线为正弦曲线，原理也是类似的：根据正弦曲线的函数表达式（`f(x)=sinx`），在特定的时间令CPU忙/闲比例为特定值即可。

##1.2 中国象棋将帅问题##

###问题描述###

中国象棋中“将”、“帅”两子（令“将”为A，“帅”为B）只能在本方3×3的格子里运动，要求写一个程序，输出A、B的所有可能位置组合，并且在代码中只能使用一个字节存储变量。

###解决思路###

- A和B理论上有3×3=9种可能的位置，再除去规则不允许的位置，实际可能的位置要少于9种。

- 在代码中只能使用一个字节来存储两个棋子的位置，可以采用8位的byte类型变量，用变量的前4bit存储A的位置，后4bit存储B的位置，由于4个bit可以表示16个数，因此这样就够用了。

- 延伸：bit级别的操作：
	+ 将一个变量（例如10100101）的右半部分（0101）设为某特定值n（例如0011）。做法是先清除该变量的右半部分（与11110000按位与，将右半部分全部清零），得到10100000；再将该结果与n（00000011）按位或，得到最终结果10100011。

	+ 将一个变量（例如10100101）的左半部分（1010）设为某特定值n（例如0011）。做法是先清除该变量的左半部分（与00001111按位与，将左半部分全部清零），得到00000101；然后将n左移4位，得到00110000；最后将以上两个结果按位或，得到最终结果00110101。

	+ 得到某一变量（例如10100101）的左半部分（1010）或右半部分（0101）。做法是将该变量与00001111进行按位与，得到右半部分（0101）；将该变量与11110000进行按位与，再将其右移4位，得到左半部分（1010）。

##1.3 一摞烙饼的排序##

###问题描述###

对于一摞烙饼，每次只允许翻转上面的一部分（将它们全部颠倒个个儿），求问这样如何将原本无序的烙饼按形状排好序？

###解决思路###

- 基本的解决思想是：首先找到最大的一个饼，将该饼连同其之上的所有饼翻转一次（这样最大的这个饼就被翻到最上面了）；然后把所有的n个烙饼翻转，这样就把最大的烙饼放在最底下了；接着对剩下的n-1个饼重复该过程，就能完成排序了。

- 算法分析：以上算法中，每循环一次该过程，就需要翻转两次（把最大的翻上去，再全部翻转一次），因此一共需要2(n-1)次翻转。

- 算法优化：除了以上翻转策略外，还可以采用动态规划方式考察所有的翻转策略，找出所需翻转次数最少的策略。考察每种策略退出的条件为：烙饼已经完成排序，或者尚未完成排序但翻转次数已经超过2(n-1)了（因为这样就肯定不是最优策略了）。

##1.4 买书问题##

###问题描述###

待补充

###解决思路###

待补充

###背景知识——动态规划###

- 动态规划算法的基本思想与分治算法类似，也是将待求解的问题分解为若干个子问题（阶段）。但是动态规划算法与分治算法的最大差别在于：动态规划算法的子问题之间往往不是相互独立的（下一阶段子问题的求解是建立在上一阶段子问题的解之上的）；而分治算法的子问题之间一般都是相互独立、互不影响的。

- 适用动态规划算法的问题一般应满足**最优化原理**（整个问题的最优解所包含的子问题的解也是最优的）和**无后效性**（即某阶段的状态一旦确定，就不受这个状态之后决策的影响）。

- 动态规划算法的求解，最主要的是确定**状态转移方程**，来表示从前一个阶段转化到后一个阶段的递推关系。整个动态规划的求解过程可以用一个二维的**最优决策表**来描述，其中行表示决策的每一个阶段，列表示每一个状态。表中存储的是某个阶段某个状态下的最优解。填表的过程就是根据状态转移方程描述的递推关系，从第1行第1列开始依次填写表格。最后根据整个表格中的数据得到整个问题的最终解。

- 动态规划算法的详细资料及算法示例参见[http://blog.csdn.net/v_JULY_v/article/details/6110269](http://blog.csdn.net/v_JULY_v/article/details/6110269)。

##1.5 快速找出故障机器##

###问题描述###

1. 在一个序列中有很多ID，每个ID均出现了两次。现在丢失了其中的一个ID（也即该ID现在只出现了一次），求问如何找出这个丢失的ID？

2. 在问题1的序列中，若丢失了其中的两个ID呢？如何找到这两个丢失的ID？

###解决思路###

####问题1的解法####

1. 解法一：采用**异或**的方式。将序列中的所有ID进行异或操作，由于其余每个ID均出现两次，而X⊕X=0、X⊕0=X，并且异或满足交换律和结合率，因此所有ID的异或值就等于仅出现一次的那个ID，也就是丢失的那个ID。

2. 解法二：预先计算好序列中所有ID的和（丢失ID之前），再计算丢失ID之后序列中其余所有ID之和，这两者之差就是丢失的那个ID。

####问题2的解法####

1. 解法一：采用**异或**的方式。设这两个丢失的ID分别为A和B，那么将所有ID异或后得到的值为A⊕B，分两种情况讨论：
	
	+ 若A⊕B=0，说明A=B，也即丢失的两个是同一个ID，则可以采用求和的方式，计算丢失之前和丢失之后的ID和之差，再除以2即为丢失的ID。
	
	+ 若A⊕B!=0，说明A和B是两个不同的ID，那么这个异或值的二进制中的某一位等于1，这意味着A和B中有且仅有一个数的相应位上也是1。进一步，我们可以将所有ID分为两类，一类在这一位上等于1，另一类在这一位上等于0。这两类分别包含A和B中的一个，于是该问题转化为了问题1（序列中包含一个丢失的ID），这时分别对这两类序列进行异或操作，即可求得A和B的值。

2. 解法二：与问题1的解法二类似，设这两个丢失的ID分别为A和B，用预先计算好的序列中所有ID之和减去丢失之后剩余ID之和，即得到A+B的值。此时有两个未知数，但只有一个方程，我们可以再构造一个方程，例如A^2+B^2（计算丢失前/丢失后所有ID的平方和之差），然后解这个二元方程组，就可以求得A和B的值了。

####注意####

- 以上提供的解法时间复杂度为O(N)（需要线性遍历一遍序列），空间复杂度为O(1)（仅需存储异或值、和值、平方和值等几个变量），已经是最优算法。

- 若将问题再做扩展，寻找丢失的N个ID，可以遵循问题2的解法二的思路，构造N元方程组，提供N个方程（例如立方和、四次方和等等），即可解决。

##1.6 饮料供货问题##

###问题描述###

待补充

###解决思路###

待补充

##1.7 光影切割问题##

###问题描述###

![](http://i.imgur.com/p17t8NF.png)

如图所示，如何计算仓库地板被光影总共划分为多少块？

###解决思路###

- 根据观察并总结数学规律可以得出结论：被光影划分的块数=N+M+1，其中N为光线个数，M为光线之间的交点个数。

- 光线个数N很容易获得，而光线之间的交点个数M的求解方法可以转化为对序列逆序数的求解。如下图所示：令三条光线与左边界的交点为有序序列（a,b,c），则与右边界的交点为无序序列（c,b,a），该序列的逆序数为3，也即光线之间的交点个数为3。该结论可以表述如下：交点个数等于一个边界上的交点顺序相对于另一个边界上交点顺序的逆序总数。

![](http://i.imgur.com/66YnLRp.png)

- **逆序数的求解**方法与归并排序算法类似，采用分治思想：

	+ 首先递归地求解前N/2个元素的逆序数和后N/2个元素的逆序数。

	+ 然后合并前后两部分的逆序数。总的逆序数=前半部分逆序数（可递归求出）+后半部分逆序数（可递归求出）+前后两部分元素之间的逆序数。

	+ 前后两部分元素之间的逆序数的求解方法为：将前半部分（设为seq1）和后半部分（设为seq2）采用归并排序进行合并（注意由于采用归并排序，所以此时seq1和seq2已经递归地排好序了）。假设归并排序在seq1设置的游标为i，在seq2设置的游标为j，则若seq1[i]<=seq2[j]，则没有逆序；若seq1[i]>seq2[j]，则说明seq1中位于seq1[i]之后的所有元素都大于seq2[j]，则逆序数为“seq1中位于seq1[i]之后的元素个数”。如此随着游标i、j的不断右移，将得到的逆序数累加起来，就能得出前后两部分元素之间的逆序总数。

	+ 这种求逆序数的方式实际上是在归并排序的过程中“顺便”求得了逆序数。

##1.8 小飞的电梯调度算法##

###问题描述###

假设一栋大楼里的电梯只能停在第x层，所有的乘客都需要乘电梯坐到x层后步行上楼/下楼走到自己的目的楼层，请问x应当取何值能够保证所有乘客爬楼梯的层数之和最小？

###解决思路###

####解法一####

简单的穷举法：从第一层开始枚举直到最高层，对每一层计算出如果电梯停在该层则所有乘客要爬多少层楼梯，取最小值及相应楼层即为最终解。

该方法包含两个for循环，外层循环遍历每一层；内层循环遍历当电梯停在该层时，要去其余各个楼层的乘客数目。因此该算法时间复杂度为O(N^2)。

####解法二####

假设电梯停在i层楼，设N1个乘客的目的楼层在i层以下、N2个乘客的目的楼层在i层、N3个乘客的目的楼层在i层以上。考虑以下两种情况：
	
+ 若电梯改停在i-1层，则位于i层以下的N1个乘客可以少爬一层，位于i层及以上的N2+N3个乘客要多爬一层，因此要多爬（N2+N3-N1）层。

+ 若电梯改停在i+1层，则位于i层及以下的N1+N2个乘客要多爬一层，位于i层以上的N3个乘客可以少爬一层，因此要多爬（N1+N2-N3）层。

根据上述分情况讨论，可以得出下列结论：

+ 若N2+N3<N1，则停在i-1层更好。

+ 若N1+N2<N3，则停在i+1层更好。

+ 其余情况下，停在i层更好。

根据以上分析，可以写出代码如下：

	int nPerson[]; //nPerson[i]表示目的楼层为第i层的乘客数目
	int nMinFloor, nTargetFloor; //nMinFloor为最小的爬楼梯总层数，nTargetFloor为相应的楼层
	int N1, N2, N3;

	nTargetFloor = 1;
	nMinFloor = 0;
	
	//初始化（计算电梯停在第一层时的各变量值，包括N1、N2、N3、nMinFloor）
	for(N1=0, N2=nPerson[1], N3=0, i=2;   i<=N;   i++){
		N3+=nPerson[i];
		nMinFloor += nPerson[i]*(i-1);
	}
	
	//从第二层开始，依次计算第2、3、4、...层的相关变量值
	for(i=2; i<=N; i++){
		//若N1+N2<N3，则根据上述结论，停在第i+1层更好，更新相关变量为第i+1层的情形，循环继续
		if(N1+N2<N3){
			nTargetFloor = i;
			nMinFloor += (N1+N2-N3);
			N1+=N2;
			N2=nPerson[i];
			N3-=nPerson[i];
		}
		//否则停在当前层（第i层）最好，直接退出循环
		else 
			break;
	}
	//返回结果
	return (nTargetFloor, nMinFloor);

注意，对于上述程序可能会有如下疑问：假如当前停在第i层，循环一次后，若第i+1层比第i层要坏，则循环直接退出了，那么有没有可能第i+2层（或更高层）比第i层更好，从而被遗漏掉了呢？答案是否定的，简单地列式计算一下即可。

##1.9 高效率地安排见面会##

###问题描述###

已知有n位学生，m个研究组，其中每个学生都对若干个研究组感兴趣。现在要安排学生参与自己感兴趣研究组的见面会，假设每个见面会的时长为t，那么如何安排才能使得所有见面会的总时长最短？

###解决思路###

- 该问题可以如下抽象：把每个研究组看成一些散布的点，如果有一位同学同时对两个研究组感兴趣，则在这两个研究组对应的点之间加上一条边；如果有同学同时对k个研究组感兴趣，那么这k个研究组对应的点两两之间都要加上一条边。于是该问题就抽象为了**最少着色问题**。

- **最少着色问题**指的是，对于一个无向图G(E,V)，试用最少的颜色为这个图的顶点着色，使得∀(vi,vj)∈E，有vi和vj的颜色不同。（对应于我们的问题，也就是说只要有同学对某两个研究组感兴趣，那么相应的两点之间就有一条边，我们就应该把这两个研究组的见面会安排在不同的时间，也即着上不同的颜色）

- 最少着色问题至今没有有效的算法，有待深入研究。

##1.10 双线程高效下载##

###问题描述###

假设有两个任务：任务A是从网络上下载数据，任务B是将数据存储到硬盘上。基本的做法是串行执行两个任务：先下载一块数据，然后写入硬盘；然后再下载，再写入硬盘……不断循环这个过程。那么如何才能让这两个任务并行处理呢？

###解决思路###

- 首先使用一个**全局缓存区**，该缓存区可以供下载任务和写磁盘任务使用。

- 分别为下载任务和写磁盘任务创建一个线程，由于这两个线程要并行处理，而且会同时访问全局缓存区（下载线程向缓存区写入数据，写磁盘线程从缓存区读取数据），因此应当采用**信号量**机制。

- **信号量**与**互斥锁**均为进程（线程）间通信机制，两者的区别：

	+ 信号量Semaphore用于多进程（线程）之间的**同步**，只要信号量的值大于0，可以允许多个进程（线程）同时访问某个资源。

	+ 互斥锁Mutex用于多进程（线程）之间的**互斥**，同一时间只能允许一个进程（线程）访问某个资源。

	+ 上述问题中，由于需要下载线程和写磁盘线程同时运行，也即同时访问全局缓存区，因此不能采用互斥锁机制，而要采用信号量机制。

##1.11 NIM（1） 一排石头的游戏##

###问题描述###

N个石头排成一行，两个玩家交替取石头，每次可以取其中任意一块石头，或者相邻的两块石头。并且取石头的时候不会影响其他石头。最后能将剩下的石头一次取光的玩家获胜。请问这个游戏有必胜策略么？

###解决思路###

- 可以从N=1、2、3……等特例具体分析，总结其中的规律，将其扩展到N的情形。

- 当N=1或2时，先取者可以一次取完，获胜。

- 当N=3时，如下图所示，先取者可以取中间的2号石头，然后后取者只能取1号或3号，最后剩一块石头，先取者取完获胜。

![](http://i.imgur.com/UVHwOWi.png)

- 当N=4时，如下图所示，先取者可以取中间相邻的2号、3号两块石头，然后后取者只能取1号或4号，最后剩一块石头，先取者取完获胜。

![](http://i.imgur.com/04PQOLC.png)

- 从以上简单的特例可以总结出规律：当N为奇数时，先取者取中间的一个；当N为偶数时，先取者取中间相邻的两个，这样就把石头分成对称的两堆。之后每次后取者取了哪块石头，先取者就取对称的那块石头即可。这样可以保证每次都有石头取，最后必将一次取完所有的石头，从而获胜。

- 以上解决思路采用了从特例到一般情形的推广，当遇到问题中包含“N个”之类的字眼时，往往可以考虑这种解决思路。

##1.12 NIM（2） “拈”游戏分析##

###问题描述###

有N块石头，两个玩家A和B。玩家A先将石头分成若干堆，然后按照B、A、B、A……的顺序不断轮流取石头，最后能将剩下的石头一次取光的玩家获胜。每次取石头只能任选一堆，并从这一堆石头中取任意数目的石头。

###解决思路###

- 采用类似于NIM（1）的思路，从简单的特例开始分析，最终推广到一般情形。

- 具体解决方法略，参见P71。

##1.13 NIM（3） 两堆石头的游戏##

###问题描述###

待补充

###解决思路###

待补充

###相关知识——构造质数的“筛子”算法###

- 要找到所有从2开始的质数，首先将所有数都排列出来，2、3、4、5、6、7……。

- 处理2：找到所有2的倍数（2本身除外），把它们都“筛掉”。

- 处理3：既然3没有被筛掉，说明它是质数，找到所有3的倍数（3本身除外），把它们都“筛掉”。

- 处理4：它已经被筛掉了。

- 处理5：既然5没有被筛掉，说明它是质数，找到所有5的倍数（5本身除外），把它们都筛掉。

- 如此这样下去，最终把所有合数都筛掉，剩下的2、3、5、7……就是质数。

- 这种算法的思想值得借鉴：我们可以先将所有可能情形通过表格等方式列出来，然后逐趟筛掉不满足要求的情形，那么剩余的情形就是符合问题要求的解。

##1.14 连连看游戏设计##

###问题描述###

设计并实现连连看游戏。关键之处在于两个图形相消的条件：

- 两个图形一样

- 两个图形之间存在少于3个弯的路径，也即**最短路径**的长度小于等于3

###解决思路###

求两个相同图形之间的最短路径可以采用**广度优先搜索**思想。广度优先思想就是先找到所有距离初始节点为k的节点，再找到所有距离初始节点为k+1的节点。

判断两个图形A和B是否可以相消的算法具体步骤如下：

- 先把图形A压入队列。

- 然后找到A可以直线到达的格子（从A到达这些格子的转弯数目为0），设这些格子的集合为S0。若图形B位于S0中，则A与B可以用直线连接，可以相消。

- 然后对于S0中的所有空格子（没有图形的格子），分别找到它们可以直线到达的格子，设这些格子的集合为S1。由于S1包含了S0，所以令S1'=S1-S0，则从A到达S1'中的格子的转弯数目为1。若图形B位于S1'中，则A和B之间需要1次转弯，可以相消。

- 然后对于S1'中的所有空格子（没有图形的格子），分别找到它们可以直线到达的格子，设这些格子的集合为S2，由于S2包含了S1和S0，所以令S2'=S2-S1-S0，则从A到达集合S2'中的格子的转弯数目为2。若图形B位于S2'中，则A和B之间需要2次转弯，可以相消。

- 若图形B不在S0、S1'或S2'中，则A和B之间至少需要3次转弯，那么A和B不能相消。

##1.15 构造数独##

###问题描述###

数独游戏的棋盘是9×9个小方格组成的。如何构造一个数独的合法解呢？

###解决思路###

构造数独的合法解可以采用**深度优先搜索**思想。深度优先搜索思想就是先沿着树的深度尽可能深地访问节点，若走到头走不通了，再**回溯**沿着别的路径访问其他节点。

构造数独合法解的算法流程如下：

- 从棋盘的左上角（0,0）开始，对于没有处理的格子，首先获取当前格子可能的取值选择，并从中选取一个作为当前格子的取值。

- 接着搜索下一个格子，也是先获取该格子可能的取值选择，然后从中选取一个作为该格子的取值。

- 在搜索过程中，若某个格子没有可行的取值，说明走不通了，此时应当**回溯**，修改前一个格子的取值，尝试别的取值方案。

- 经过不断的向前搜索和回溯再搜索，直到所有的格子都找到可行的取值为止，便生成了一个合法解。

##1.16 24点游戏##

###问题描述###

24点的游戏规则是：给玩家4张牌，每张牌的面值在1——13中间，允许其中有相同数值的牌。采用+、-、×、÷四则运算和小括号，使用给定的4张牌的数值构造一个表达式，使得该表达式的运算结果等于24。例如给定11、8、3、5这四张牌，可以构造表达式(11-8)×(3+5)=24。

那么，如何根据给定的4张牌得到所有可能的合法解呢？

###解决思路###

- 直接穷举所有的表达式的计算量太大，效率太低，不予考虑。

- 但是穷举法提供了一种思路：遍历运算符、数字和括号的所有排列组合形式。接下来应该考虑如何优化这一思路。对此可以采用**分治**的思想进行处理，具体如下：

	+ 以具体实例说明，假设给定的4张牌为{1,2,3,4}。

	+ 首先从初始集合中任意取出两个数，例如取出1和2，对取出来的这两个数进行所有可能的四则运算：1+2=3, 1-2=-1, 1×2=2， 1÷2=0.5，将四则运算的结果放入初始集合中，并移除取出的两个数，得到{3,3,4}、{-1,3,4}、{2,3,4}、{0.5,3,4}这四个子集合。于是原问题的解就化归为这四个子问题的解的**并集**。问题规模就从4个数降为3个数，这体现了分治的思想（将原问题化归为相互独立的几个子问题，分别求得子问题的解之后进行合并，得到原问题的解）。

	+ 根据以上思路，可以写出算法的伪代码：

			f(array){
				//递归的退出条件
				if(array.length < 2){
					//有解
					if(得到的最终结果为24) 输出合法解的表达式
					//无解
					else 无法构造合法解，输出失败信息
				}	
				
				//遍历数字
				foreach(从输入集合中任取两个数){
					//遍历运算符
					foreach(运算符+、-、×、÷){

						1.计算这两个数在此运算符下的计算结果

						2.构造子问题的输入集合（从原集合中移除这两个数，然后将步骤1的计算结果放入）

						//分治处理
						3.对子问题的输入集合递归调用f，如果找到一个合法解则返回

						//将输入集合恢复原状，从而不对后续循环产生影响
						4.将输入集合恢复为原问题的输入集合（移除步骤1的计算结果，将任取的两个数重新放回）

					}
				}
			}


##1.17 俄罗斯方块游戏##

###问题描述###

设计并实现一个俄罗斯方块游戏，重点在于用什么数据结构来表示游戏中的各种元素？如何让计算机智能来玩这个游戏？

###解决思路###

- 可以采用二维数组area[M][N]来表示M*N的游戏区域。其中，数组元素值为0表示该处没有方块，值为1表示有方块。

- 游戏中所有可能出现的积木块形状如下图所示，可以采用统一尺寸的4×4的二维数组来表示这些积木块。与游戏区域的表示方法一样，数组元素值为0表示该处没有方块，值为1表示该处有方块。此外，我们可以预先计算好每种积木块的各个旋转形状（每种积木块有4个旋转形状），在程序中可以直接使用。

![](http://i.imgur.com/E2SFFts.png)

- 要让计算机智能玩俄罗斯方块，最重要的一点是让计算机判断哪种积木摆放方式是“好”的，哪种是“不好”的。为了便于计算机处理，我们应该把主观的“好”、“坏”进行**量化**，采用“计分制”：例如每消除一层则加2分，每形成一个洞则扣10分。然后计算每种可能的摆放方式的得分，从而选择最优的方式。

##1.18 挖雷游戏##

###问题描述###

待补充

###解决思路###

待补充